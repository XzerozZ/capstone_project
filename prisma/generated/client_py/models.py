# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template models.py.jinja --
import os
import logging
import inspect
import warnings
from collections import OrderedDict

from pydantic import BaseModel, Field

from . import types, enums, errors, fields, bases
from ._types import FuncType
from ._compat import model_rebuild, field_validator
from ._builder import serialize_base64
from .generator import partial_models_ctx, PartialModelField


log: logging.Logger = logging.getLogger(__name__)
_created_partial_types: Set[str] = set()

class user(bases.Baseuser):
    """Represents a user record"""

    user_id: _int
    first_name: _str
    last_name: _str
    username: _str
    image: Optional[_str] = None
    phone_number: _str
    id_card: _str
    email: _str
    password: _str
    role: _str
    post: Optional[List['models.post']] = None
    rating_user1: Optional[List['models.rating_user']] = None
    rating_users2: Optional[List['models.rating_user']] = None
    rating_com1: Optional[List['models.rating_com']] = None
    rating_com2: Optional[List['models.rating_com']] = None
    contact: Optional[List['models.contact']] = None
    experience: Optional[List['models.experience']] = None
    user_career: Optional[List['models.user_career']] = None
    history: Optional[List['models.history']] = None
    bookmark: Optional[List['models.bookmark']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.userKeys']] = None,
        exclude: Optional[Iterable['types.userKeys']] = None,
        required: Optional[Iterable['types.userKeys']] = None,
        optional: Optional[Iterable['types.userKeys']] = None,
        relations: Optional[Mapping['types.userRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.userKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _user_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _user_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _user_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _user_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _user_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _user_relational_fields:
                        raise errors.UnknownRelationalFieldError('user', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid user / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'user',
            }
        )
        _created_partial_types.add(name)


class rating_user(bases.Baserating_user):
    """Represents a rating_user record"""

    rating_id: _int
    user_id1: _int
    user_id2: _int
    job_id: _int
    friendly_rating: _float
    efficiency_rating: _float
    accuracy_rating: _float
    user1: Optional['models.user'] = None
    user2: Optional['models.user'] = None
    job: Optional['models.job'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.rating_userKeys']] = None,
        exclude: Optional[Iterable['types.rating_userKeys']] = None,
        required: Optional[Iterable['types.rating_userKeys']] = None,
        optional: Optional[Iterable['types.rating_userKeys']] = None,
        relations: Optional[Mapping['types.rating_userRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.rating_userKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _rating_user_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _rating_user_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _rating_user_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _rating_user_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _rating_user_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _rating_user_relational_fields:
                        raise errors.UnknownRelationalFieldError('rating_user', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid rating_user / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'rating_user',
            }
        )
        _created_partial_types.add(name)


class rating_com(bases.Baserating_com):
    """Represents a rating_com record"""

    rating_id: _int
    user_id1: _int
    user_id2: _int
    job_id: _int
    rating: _float
    user1: Optional['models.user'] = None
    user2: Optional['models.user'] = None
    job: Optional['models.job'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.rating_comKeys']] = None,
        exclude: Optional[Iterable['types.rating_comKeys']] = None,
        required: Optional[Iterable['types.rating_comKeys']] = None,
        optional: Optional[Iterable['types.rating_comKeys']] = None,
        relations: Optional[Mapping['types.rating_comRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.rating_comKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _rating_com_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _rating_com_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _rating_com_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _rating_com_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _rating_com_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _rating_com_relational_fields:
                        raise errors.UnknownRelationalFieldError('rating_com', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid rating_com / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'rating_com',
            }
        )
        _created_partial_types.add(name)


class contact(bases.Basecontact):
    """Represents a contact record"""

    contact_id: _int
    user_id: _int
    facebook: _str
    instagram: _str
    linkedin: _str
    user: Optional['models.user'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.contactKeys']] = None,
        exclude: Optional[Iterable['types.contactKeys']] = None,
        required: Optional[Iterable['types.contactKeys']] = None,
        optional: Optional[Iterable['types.contactKeys']] = None,
        relations: Optional[Mapping['types.contactRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.contactKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _contact_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _contact_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _contact_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _contact_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _contact_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _contact_relational_fields:
                        raise errors.UnknownRelationalFieldError('contact', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid contact / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'contact',
            }
        )
        _created_partial_types.add(name)


class category(bases.Basecategory):
    """Represents a category record"""

    category_id: _int
    name: _str
    experiences: Optional[List['models.experience']] = None
    job_exp: Optional[List['models.job_exp']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.categoryKeys']] = None,
        exclude: Optional[Iterable['types.categoryKeys']] = None,
        required: Optional[Iterable['types.categoryKeys']] = None,
        optional: Optional[Iterable['types.categoryKeys']] = None,
        relations: Optional[Mapping['types.categoryRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.categoryKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _category_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _category_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _category_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _category_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _category_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _category_relational_fields:
                        raise errors.UnknownRelationalFieldError('category', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid category / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'category',
            }
        )
        _created_partial_types.add(name)


class experience(bases.Baseexperience):
    """Represents a experience record"""

    user_id: _int
    category_id: _int
    user: Optional['models.user'] = None
    category: Optional['models.category'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.experienceKeys']] = None,
        exclude: Optional[Iterable['types.experienceKeys']] = None,
        required: Optional[Iterable['types.experienceKeys']] = None,
        optional: Optional[Iterable['types.experienceKeys']] = None,
        relations: Optional[Mapping['types.experienceRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.experienceKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _experience_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _experience_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _experience_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _experience_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _experience_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _experience_relational_fields:
                        raise errors.UnknownRelationalFieldError('experience', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid experience / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'experience',
            }
        )
        _created_partial_types.add(name)


class career(bases.Basecareer):
    """Represents a career record"""

    career_id: _int
    name: _str
    user_career: Optional[List['models.user_career']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.careerKeys']] = None,
        exclude: Optional[Iterable['types.careerKeys']] = None,
        required: Optional[Iterable['types.careerKeys']] = None,
        optional: Optional[Iterable['types.careerKeys']] = None,
        relations: Optional[Mapping['types.careerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.careerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _career_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _career_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _career_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _career_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _career_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _career_relational_fields:
                        raise errors.UnknownRelationalFieldError('career', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid career / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'career',
            }
        )
        _created_partial_types.add(name)


class user_career(bases.Baseuser_career):
    """Represents a user_career record"""

    user_id: _int
    career_id: _int
    user: Optional['models.user'] = None
    career: Optional['models.career'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.user_careerKeys']] = None,
        exclude: Optional[Iterable['types.user_careerKeys']] = None,
        required: Optional[Iterable['types.user_careerKeys']] = None,
        optional: Optional[Iterable['types.user_careerKeys']] = None,
        relations: Optional[Mapping['types.user_careerRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.user_careerKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _user_career_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _user_career_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _user_career_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _user_career_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _user_career_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _user_career_relational_fields:
                        raise errors.UnknownRelationalFieldError('user_career', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid user_career / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'user_career',
            }
        )
        _created_partial_types.add(name)


class job(bases.Basejob):
    """Represents a job record"""

    job_id: _int
    title: _str
    description: _str
    budget: _int
    type: _str
    posted_date: datetime.datetime
    submitted_date: Optional[datetime.datetime] = None
    status: _str
    history: Optional[List['models.history']] = None
    job_exp: Optional[List['models.job_exp']] = None
    rating_user: Optional[List['models.rating_user']] = None
    rating_com: Optional[List['models.rating_com']] = None
    bookmark: Optional[List['models.bookmark']] = None
    post: Optional[List['models.post']] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.jobKeys']] = None,
        exclude: Optional[Iterable['types.jobKeys']] = None,
        required: Optional[Iterable['types.jobKeys']] = None,
        optional: Optional[Iterable['types.jobKeys']] = None,
        relations: Optional[Mapping['types.jobRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.jobKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _job_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _job_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _job_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _job_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _job_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _job_relational_fields:
                        raise errors.UnknownRelationalFieldError('job', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid job / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'job',
            }
        )
        _created_partial_types.add(name)


class history(bases.Basehistory):
    """Represents a history record"""

    user_id: _int
    job_id: _int
    user: Optional['models.user'] = None
    job: Optional['models.job'] = None
    status: _str

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.historyKeys']] = None,
        exclude: Optional[Iterable['types.historyKeys']] = None,
        required: Optional[Iterable['types.historyKeys']] = None,
        optional: Optional[Iterable['types.historyKeys']] = None,
        relations: Optional[Mapping['types.historyRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.historyKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _history_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _history_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _history_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _history_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _history_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _history_relational_fields:
                        raise errors.UnknownRelationalFieldError('history', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid history / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'history',
            }
        )
        _created_partial_types.add(name)


class job_exp(bases.Basejob_exp):
    """Represents a job_exp record"""

    job_id: _int
    category_id: _int
    job: Optional['models.job'] = None
    category: Optional['models.category'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.job_expKeys']] = None,
        exclude: Optional[Iterable['types.job_expKeys']] = None,
        required: Optional[Iterable['types.job_expKeys']] = None,
        optional: Optional[Iterable['types.job_expKeys']] = None,
        relations: Optional[Mapping['types.job_expRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.job_expKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _job_exp_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _job_exp_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _job_exp_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _job_exp_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _job_exp_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _job_exp_relational_fields:
                        raise errors.UnknownRelationalFieldError('job_exp', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid job_exp / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'job_exp',
            }
        )
        _created_partial_types.add(name)


class bookmark(bases.Basebookmark):
    """Represents a bookmark record"""

    book_id: _int
    user_id: _int
    job_id: _int
    user: Optional['models.user'] = None
    job: Optional['models.job'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.bookmarkKeys']] = None,
        exclude: Optional[Iterable['types.bookmarkKeys']] = None,
        required: Optional[Iterable['types.bookmarkKeys']] = None,
        optional: Optional[Iterable['types.bookmarkKeys']] = None,
        relations: Optional[Mapping['types.bookmarkRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.bookmarkKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _bookmark_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _bookmark_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _bookmark_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _bookmark_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _bookmark_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _bookmark_relational_fields:
                        raise errors.UnknownRelationalFieldError('bookmark', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid bookmark / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'bookmark',
            }
        )
        _created_partial_types.add(name)


class post(bases.Basepost):
    """Represents a post record"""

    user_id: _int
    job_id: _int
    user: Optional['models.user'] = None
    job: Optional['models.job'] = None

    # take *args and **kwargs so that other metaclasses can define arguments
    def __init_subclass__(
        cls,
        *args: Any,
        warn_subclass: Optional[bool] = None,
        **kwargs: Any,
    ) -> None:
        super().__init_subclass__()
        if warn_subclass is not None:
            warnings.warn(
                'The `warn_subclass` argument is deprecated as it is no longer necessary and will be removed in the next release',
                DeprecationWarning,
                stacklevel=3,
            )


    @staticmethod
    def create_partial(
        name: str,
        include: Optional[Iterable['types.postKeys']] = None,
        exclude: Optional[Iterable['types.postKeys']] = None,
        required: Optional[Iterable['types.postKeys']] = None,
        optional: Optional[Iterable['types.postKeys']] = None,
        relations: Optional[Mapping['types.postRelationalFieldKeys', str]] = None,
        exclude_relational_fields: bool = False,
    ) -> None:
        if not os.environ.get('PRISMA_GENERATOR_INVOCATION'):
            raise RuntimeError(
                'Attempted to create a partial type outside of client generation.'
            )

        if name in _created_partial_types:
            raise ValueError(f'Partial type "{name}" has already been created.')

        if include is not None:
            if exclude is not None:
                raise TypeError('Exclude and include are mutually exclusive.')
            if exclude_relational_fields is True:
                raise TypeError('Include and exclude_relational_fields=True are mutually exclusive.')

        if required and optional:
            shared = set(required) & set(optional)
            if shared:
                raise ValueError(f'Cannot make the same field(s) required and optional {shared}')

        if exclude_relational_fields and relations:
            raise ValueError(
                'exclude_relational_fields and relations are mutually exclusive'
            )

        fields: Dict['types.postKeys', PartialModelField] = OrderedDict()

        try:
            if include:
                for field in include:
                    fields[field] = _post_fields[field].copy()
            elif exclude:
                for field in exclude:
                    if field not in _post_fields:
                        raise KeyError(field)

                fields = {
                    key: data.copy()
                    for key, data in _post_fields.items()
                    if key not in exclude
                }
            else:
                fields = {
                    key: data.copy()
                    for key, data in _post_fields.items()
                }

            if required:
                for field in required:
                    fields[field]['optional'] = False

            if optional:
                for field in optional:
                    fields[field]['optional'] = True

            if exclude_relational_fields:
                fields = {
                    key: data
                    for key, data in fields.items()
                    if key not in _post_relational_fields
                }

            if relations:
                for field, type_ in relations.items():
                    if field not in _post_relational_fields:
                        raise errors.UnknownRelationalFieldError('post', field)

                    # TODO: this method of validating types is not ideal
                    # as it means we cannot two create partial types that
                    # reference each other
                    if type_ not in _created_partial_types:
                        raise ValueError(
                            f'Unknown partial type: "{type_}". '
                            f'Did you remember to generate the {type_} type before this one?'
                        )

                    # TODO: support non prisma.partials models
                    info = fields[field]
                    if info['is_list']:
                        info['type'] = f'List[\'partials.{type_}\']'
                    else:
                        info['type'] = f'\'partials.{type_}\''
        except KeyError as exc:
            raise ValueError(
                f'{exc.args[0]} is not a valid post / {name} field.'
            ) from None

        models = partial_models_ctx.get()
        models.append(
            {
                'name': name,
                'fields': cast(Mapping[str, PartialModelField], fields),
                'from_model': 'post',
            }
        )
        _created_partial_types.add(name)



_user_relational_fields: Set[str] = {
        'post',
        'rating_user1',
        'rating_users2',
        'rating_com1',
        'rating_com2',
        'contact',
        'experience',
        'user_career',
        'history',
        'bookmark',
    }
_user_fields: Dict['types.userKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('first_name', {
            'name': 'first_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('last_name', {
            'name': 'last_name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('username', {
            'name': 'username',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('image', {
            'name': 'image',
            'is_list': False,
            'optional': True,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('phone_number', {
            'name': 'phone_number',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('id_card', {
            'name': 'id_card',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('email', {
            'name': 'email',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('password', {
            'name': 'password',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('role', {
            'name': 'role',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.post\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_user1', {
            'name': 'rating_user1',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_user\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_users2', {
            'name': 'rating_users2',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_user\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_com1', {
            'name': 'rating_com1',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_com\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_com2', {
            'name': 'rating_com2',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_com\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('contact', {
            'name': 'contact',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.contact\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('experience', {
            'name': 'experience',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.experience\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('user_career', {
            'name': 'user_career',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.user_career\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('history', {
            'name': 'history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('bookmark', {
            'name': 'bookmark',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.bookmark\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_rating_user_relational_fields: Set[str] = {
        'user1',
        'user2',
        'job',
    }
_rating_user_fields: Dict['types.rating_userKeys', PartialModelField] = OrderedDict(
    [
        ('rating_id', {
            'name': 'rating_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id1', {
            'name': 'user_id1',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id2', {
            'name': 'user_id2',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('friendly_rating', {
            'name': 'friendly_rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('efficiency_rating', {
            'name': 'efficiency_rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('accuracy_rating', {
            'name': 'accuracy_rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('user1', {
            'name': 'user1',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('user2', {
            'name': 'user2',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_rating_com_relational_fields: Set[str] = {
        'user1',
        'user2',
        'job',
    }
_rating_com_fields: Dict['types.rating_comKeys', PartialModelField] = OrderedDict(
    [
        ('rating_id', {
            'name': 'rating_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id1', {
            'name': 'user_id1',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id2', {
            'name': 'user_id2',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('rating', {
            'name': 'rating',
            'is_list': False,
            'optional': False,
            'type': '_float',
            'is_relational': False,
            'documentation': None,
        }),
        ('user1', {
            'name': 'user1',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('user2', {
            'name': 'user2',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_contact_relational_fields: Set[str] = {
        'user',
    }
_contact_fields: Dict['types.contactKeys', PartialModelField] = OrderedDict(
    [
        ('contact_id', {
            'name': 'contact_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('facebook', {
            'name': 'facebook',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('instagram', {
            'name': 'instagram',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('linkedin', {
            'name': 'linkedin',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_category_relational_fields: Set[str] = {
        'experiences',
        'job_exp',
    }
_category_fields: Dict['types.categoryKeys', PartialModelField] = OrderedDict(
    [
        ('category_id', {
            'name': 'category_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('experiences', {
            'name': 'experiences',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.experience\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('job_exp', {
            'name': 'job_exp',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.job_exp\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_experience_relational_fields: Set[str] = {
        'user',
        'category',
    }
_experience_fields: Dict['types.experienceKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category_id', {
            'name': 'category_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.category',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_career_relational_fields: Set[str] = {
        'user_career',
    }
_career_fields: Dict['types.careerKeys', PartialModelField] = OrderedDict(
    [
        ('career_id', {
            'name': 'career_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('name', {
            'name': 'name',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_career', {
            'name': 'user_career',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.user_career\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_user_career_relational_fields: Set[str] = {
        'user',
        'career',
    }
_user_career_fields: Dict['types.user_careerKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('career_id', {
            'name': 'career_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('career', {
            'name': 'career',
            'is_list': False,
            'optional': True,
            'type': 'models.career',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_job_relational_fields: Set[str] = {
        'history',
        'job_exp',
        'rating_user',
        'rating_com',
        'bookmark',
        'post',
    }
_job_fields: Dict['types.jobKeys', PartialModelField] = OrderedDict(
    [
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('title', {
            'name': 'title',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('description', {
            'name': 'description',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('budget', {
            'name': 'budget',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('type', {
            'name': 'type',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('posted_date', {
            'name': 'posted_date',
            'is_list': False,
            'optional': False,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('submitted_date', {
            'name': 'submitted_date',
            'is_list': False,
            'optional': True,
            'type': 'datetime.datetime',
            'is_relational': False,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
        ('history', {
            'name': 'history',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.history\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('job_exp', {
            'name': 'job_exp',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.job_exp\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_user', {
            'name': 'rating_user',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_user\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('rating_com', {
            'name': 'rating_com',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.rating_com\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('bookmark', {
            'name': 'bookmark',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.bookmark\']',
            'is_relational': True,
            'documentation': None,
        }),
        ('post', {
            'name': 'post',
            'is_list': True,
            'optional': True,
            'type': 'List[\'models.post\']',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_history_relational_fields: Set[str] = {
        'user',
        'job',
    }
_history_fields: Dict['types.historyKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
        ('status', {
            'name': 'status',
            'is_list': False,
            'optional': False,
            'type': '_str',
            'is_relational': False,
            'documentation': None,
        }),
    ],
)

_job_exp_relational_fields: Set[str] = {
        'job',
        'category',
    }
_job_exp_fields: Dict['types.job_expKeys', PartialModelField] = OrderedDict(
    [
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('category_id', {
            'name': 'category_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
        ('category', {
            'name': 'category',
            'is_list': False,
            'optional': True,
            'type': 'models.category',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_bookmark_relational_fields: Set[str] = {
        'user',
        'job',
    }
_bookmark_fields: Dict['types.bookmarkKeys', PartialModelField] = OrderedDict(
    [
        ('book_id', {
            'name': 'book_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)

_post_relational_fields: Set[str] = {
        'user',
        'job',
    }
_post_fields: Dict['types.postKeys', PartialModelField] = OrderedDict(
    [
        ('user_id', {
            'name': 'user_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('job_id', {
            'name': 'job_id',
            'is_list': False,
            'optional': False,
            'type': '_int',
            'is_relational': False,
            'documentation': None,
        }),
        ('user', {
            'name': 'user',
            'is_list': False,
            'optional': True,
            'type': 'models.user',
            'is_relational': True,
            'documentation': None,
        }),
        ('job', {
            'name': 'job',
            'is_list': False,
            'optional': True,
            'type': 'models.job',
            'is_relational': True,
            'documentation': None,
        }),
    ],
)



# we have to import ourselves as relation types are namespaced to models
# e.g. models.Post
from . import models, actions

# required to support relationships between models
model_rebuild(user)
model_rebuild(rating_user)
model_rebuild(rating_com)
model_rebuild(contact)
model_rebuild(category)
model_rebuild(experience)
model_rebuild(career)
model_rebuild(user_career)
model_rebuild(job)
model_rebuild(history)
model_rebuild(job_exp)
model_rebuild(bookmark)
model_rebuild(post)

# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off
from __future__ import annotations

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template actions.py.jinja --
from typing import TypeVar
import warnings

from . import types, errors, bases
from ._compat import model_parse

if TYPE_CHECKING:
    from .client import Prisma
    from .bases import _PrismaModel


_PrismaModelT = TypeVar('_PrismaModelT', bound='_PrismaModel')


class userActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.user]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = user.prisma().query_raw(
            'SELECT * FROM user WHERE user_id = $1',
            1103527590,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.user
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = user.prisma().query_first(
            'SELECT * FROM user WHERE first_name = $1',
            'dhheabfhf',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.userCreateInput,
        include: Optional[types.userInclude] = None
    ) -> _PrismaModelT:
        """Create a new user record.

        Parameters
        ----------
        data
            user record data
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The created user record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a user record from just the required fields
        user = user.prisma().create(
            data={
                # data to create a user record
                'first_name': 'ggciceaie',
                'last_name': 'bbehjachib',
                'username': 'cadfabfehe',
                'phone_number': 'dgiiaaijj',
                'id_card': 'bfaiacjjfc',
                'email': 'eigcfgbif',
                'password': 'bagcfbhiig',
                'role': 'cghideieh',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple user records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of user record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = user.prisma().create_many(
            data=[
                {
                    # data to create a user record
                    'first_name': 'biabhbdai',
                    'last_name': 'idghgaicb',
                    'username': 'fjfddhigg',
                    'phone_number': 'hjaecfifb',
                    'id_card': 'cbbbjbfcii',
                    'email': 'bbejhfidcb',
                    'password': 'bgeecijdgg',
                    'role': 'bdiicjafbj',
                },
                {
                    # data to create a user record
                    'first_name': 'bgehebiafc',
                    'last_name': 'bghffegacj',
                    'username': 'bhghchehcc',
                    'phone_number': 'dcgchcbbf',
                    'id_card': 'bdedcabahc',
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                    'role': 'bjgjgibgbf',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.userWhereUniqueInput,
        include: Optional[types.userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single user record.

        Parameters
        ----------
        where
            user filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The deleted user record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = user.prisma().delete(
            where={
                'user_id': 1116175964,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.userWhereUniqueInput,
        include: Optional[types.userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique user record.

        Parameters
        ----------
        where
            user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The found user record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = user.prisma().find_unique(
            where={
                'user_id': 861472101,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.userWhereUniqueInput,
        include: Optional[types.userInclude] = None
    ) -> _PrismaModelT:
        """Find a unique user record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The found user record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = user.prisma().find_unique_or_raise(
            where={
                'user_id': 1303003706,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
        include: Optional[types.userInclude] = None,
        order: Optional[Union[types.userOrderByInput, List[types.userOrderByInput]]] = None,
        distinct: Optional[List[types.userScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple user records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of user records returned
        skip
            Ignore the first N results
        where
            user filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user model
        order
            Order the returned user records by any field
        distinct
            Filter user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.user]
            The list of all user records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 user records
        users = user.prisma().find_many(take=10)

        # find the first 5 user records ordered by the last_name field
        users = user.prisma().find_many(
            take=5,
            order={
                'last_name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
        include: Optional[types.userInclude] = None,
        order: Optional[Union[types.userOrderByInput, List[types.userOrderByInput]]] = None,
        distinct: Optional[List[types.userScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single user record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user model
        order
            Order the returned user records by any field
        distinct
            Filter user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user
            The first user record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user record ordered by the username field
        user = user.prisma().find_first(
            skip=1,
            order={
                'username': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
        include: Optional[types.userInclude] = None,
        order: Optional[Union[types.userOrderByInput, List[types.userOrderByInput]]] = None,
        distinct: Optional[List[types.userScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single user record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user model
        order
            Order the returned user records by any field
        distinct
            Filter user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user
            The first user record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user record ordered by the image field
        user = user.prisma().find_first_or_raise(
            skip=1,
            order={
                'image': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.userUpdateInput,
        where: types.userWhereUniqueInput,
        include: Optional[types.userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single user record.

        Parameters
        ----------
        data
            user record data specifying what to update
        where
            user filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The updated user record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = user.prisma().update(
            where={
                'user_id': 1686638315,
            },
            data={
                # data to update the user record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.userWhereUniqueInput,
        data: types.userUpsertInput,
        include: Optional[types.userInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            user filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned user model

        Returns
        -------
        prisma.models.user
            The created or updated user record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user = user.prisma().upsert(
            where={
                'user_id': 2000430152,
            },
            data={
                'create': {
                    'user_id': 2000430152,
                    'first_name': 'bgehebiafc',
                    'last_name': 'bghffegacj',
                    'username': 'bhghchehcc',
                    'phone_number': 'dcgchcbbf',
                    'id_card': 'bdedcabahc',
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                    'role': 'bjgjgibgbf',
                },
                'update': {
                    'first_name': 'bgehebiafc',
                    'last_name': 'bghffegacj',
                    'username': 'bhghchehcc',
                    'phone_number': 'dcgchcbbf',
                    'id_card': 'bdedcabahc',
                    'email': 'ghfhiafcb',
                    'password': 'heejgedji',
                    'role': 'bjgjgibgbf',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.userUpdateManyMutationInput,
        where: types.userWhereInput,
    ) -> int:
        """Update multiple user records

        Parameters
        ----------
        data
            user data to update the selected user records to
        where
            Filter to select the user records to update

        Returns
        -------
        int
            The total number of user records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all user records
        total = user.prisma().update_many(
            data={
                'phone_number': 'bigibebcib'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
    ) -> int:
        """Count the number of user records present in the database

        Parameters
        ----------
        select
            Select the user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = user.prisma().count()

        # results: prisma.types.userCountAggregateOutput
        results = user.prisma().count(
            select={
                '_all': True,
                'id_card': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.userCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
    ) -> types.userCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.userCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.userWhereInput] = None,
        cursor: Optional[types.userWhereUniqueInput] = None,
    ) -> Union[int, types.userCountAggregateOutput]:
        """Count the number of user records present in the database

        Parameters
        ----------
        select
            Select the user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = user.prisma().count()

        # results: prisma.types.userCountAggregateOutput
        results = user.prisma().count(
            select={
                '_all': True,
                'email': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.userCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.userWhereInput] = None
    ) -> int:
        """Delete multiple user records.

        Parameters
        ----------
        where
            Optional user filter to find the records to be deleted

        Returns
        -------
        int
            The total number of user records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all user records
        total = user.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.userScalarFieldKeys'],
        *,
        where: Optional['types.userWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.userAvgAggregateInput'] = None,
        sum: Optional['types.userSumAggregateInput'] = None,
        min: Optional['types.userMinAggregateInput'] = None,
        max: Optional['types.userMaxAggregateInput'] = None,
        having: Optional['types.userScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.userCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.userScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.userScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.userGroupByOutput']:
        """Group user records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar user fields to group records by
        where
            user filter to select records
        take
            Limit the maximum number of user records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.userGroupByOutput]
            A list of dictionaries representing the user record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group user records by password values
        # and count how many records are in each group
        results = user.prisma().group_by(
            ['password'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class rating_userActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.rating_user]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = rating_user.prisma().query_raw(
            'SELECT * FROM rating_user WHERE rating_id = $1',
            1860847622,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.rating_user
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = rating_user.prisma().query_first(
            'SELECT * FROM rating_user WHERE job_id = $1',
            1448521415,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.rating_userCreateInput,
        include: Optional[types.rating_userInclude] = None
    ) -> _PrismaModelT:
        """Create a new rating_user record.

        Parameters
        ----------
        data
            rating_user record data
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The created rating_user record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a rating_user record from just the required fields
        rating_user = rating_user.prisma().create(
            data={
                # data to create a rating_user record
                'job_id': 1628650740,
                'user_id1': 1249606685,
                'user_id2': 835903122,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.rating_userCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple rating_user records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of rating_user record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = rating_user.prisma().create_many(
            data=[
                {
                    # data to create a rating_user record
                    'job_id': 763719779,
                    'user_id1': 429995104,
                    'user_id2': 1775811865,
                },
                {
                    # data to create a rating_user record
                    'job_id': 893145566,
                    'user_id1': 995405759,
                    'user_id2': 2102736524,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.rating_userWhereUniqueInput,
        include: Optional[types.rating_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single rating_user record.

        Parameters
        ----------
        where
            rating_user filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The deleted rating_user record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_user = rating_user.prisma().delete(
            where={
                'rating_id': 271520213,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.rating_userWhereUniqueInput,
        include: Optional[types.rating_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique rating_user record.

        Parameters
        ----------
        where
            rating_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The found rating_user record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_user = rating_user.prisma().find_unique(
            where={
                'rating_id': 456633834,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.rating_userWhereUniqueInput,
        include: Optional[types.rating_userInclude] = None
    ) -> _PrismaModelT:
        """Find a unique rating_user record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            rating_user filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The found rating_user record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_user = rating_user.prisma().find_unique_or_raise(
            where={
                'rating_id': 2058258651,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
        include: Optional[types.rating_userInclude] = None,
        order: Optional[Union[types.rating_userOrderByInput, List[types.rating_userOrderByInput]]] = None,
        distinct: Optional[List[types.rating_userScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple rating_user records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of rating_user records returned
        skip
            Ignore the first N results
        where
            rating_user filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_user model
        order
            Order the returned rating_user records by any field
        distinct
            Filter rating_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.rating_user]
            The list of all rating_user records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 rating_user records
        rating_users = rating_user.prisma().find_many(take=10)

        # find the first 5 rating_user records ordered by the friendly_rating field
        rating_users = rating_user.prisma().find_many(
            take=5,
            order={
                'friendly_rating': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
        include: Optional[types.rating_userInclude] = None,
        order: Optional[Union[types.rating_userOrderByInput, List[types.rating_userOrderByInput]]] = None,
        distinct: Optional[List[types.rating_userScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single rating_user record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            rating_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_user model
        order
            Order the returned rating_user records by any field
        distinct
            Filter rating_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.rating_user
            The first rating_user record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second rating_user record ordered by the efficiency_rating field
        rating_user = rating_user.prisma().find_first(
            skip=1,
            order={
                'efficiency_rating': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
        include: Optional[types.rating_userInclude] = None,
        order: Optional[Union[types.rating_userOrderByInput, List[types.rating_userOrderByInput]]] = None,
        distinct: Optional[List[types.rating_userScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single rating_user record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            rating_user filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_user model
        order
            Order the returned rating_user records by any field
        distinct
            Filter rating_user records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.rating_user
            The first rating_user record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second rating_user record ordered by the accuracy_rating field
        rating_user = rating_user.prisma().find_first_or_raise(
            skip=1,
            order={
                'accuracy_rating': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.rating_userUpdateInput,
        where: types.rating_userWhereUniqueInput,
        include: Optional[types.rating_userInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single rating_user record.

        Parameters
        ----------
        data
            rating_user record data specifying what to update
        where
            rating_user filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The updated rating_user record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rating_user = rating_user.prisma().update(
            where={
                'rating_id': 1583689592,
            },
            data={
                # data to update the rating_user record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.rating_userWhereUniqueInput,
        data: types.rating_userUpsertInput,
        include: Optional[types.rating_userInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            rating_user filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned rating_user model

        Returns
        -------
        prisma.models.rating_user
            The created or updated rating_user record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_user = rating_user.prisma().upsert(
            where={
                'rating_id': 878442065,
            },
            data={
                'create': {
                    'rating_id': 878442065,
                    'job_id': 893145566,
                    'user_id1': 995405759,
                    'user_id2': 2102736524,
                },
                'update': {
                    'job_id': 893145566,
                    'user_id1': 995405759,
                    'user_id2': 2102736524,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.rating_userUpdateManyMutationInput,
        where: types.rating_userWhereInput,
    ) -> int:
        """Update multiple rating_user records

        Parameters
        ----------
        data
            rating_user data to update the selected rating_user records to
        where
            Filter to select the rating_user records to update

        Returns
        -------
        int
            The total number of rating_user records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all rating_user records
        total = rating_user.prisma().update_many(
            data={
                'user_id1': 1675280054
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
    ) -> int:
        """Count the number of rating_user records present in the database

        Parameters
        ----------
        select
            Select the rating_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            rating_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.rating_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = rating_user.prisma().count()

        # results: prisma.types.rating_userCountAggregateOutput
        results = rating_user.prisma().count(
            select={
                '_all': True,
                'user_id2': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.rating_userCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
    ) -> types.rating_userCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.rating_userCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_userWhereInput] = None,
        cursor: Optional[types.rating_userWhereUniqueInput] = None,
    ) -> Union[int, types.rating_userCountAggregateOutput]:
        """Count the number of rating_user records present in the database

        Parameters
        ----------
        select
            Select the rating_user fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            rating_user filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.rating_userCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = rating_user.prisma().count()

        # results: prisma.types.rating_userCountAggregateOutput
        results = rating_user.prisma().count(
            select={
                '_all': True,
                'rating_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.rating_userCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.rating_userWhereInput] = None
    ) -> int:
        """Delete multiple rating_user records.

        Parameters
        ----------
        where
            Optional rating_user filter to find the records to be deleted

        Returns
        -------
        int
            The total number of rating_user records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all rating_user records
        total = rating_user.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.rating_userScalarFieldKeys'],
        *,
        where: Optional['types.rating_userWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.rating_userAvgAggregateInput'] = None,
        sum: Optional['types.rating_userSumAggregateInput'] = None,
        min: Optional['types.rating_userMinAggregateInput'] = None,
        max: Optional['types.rating_userMaxAggregateInput'] = None,
        having: Optional['types.rating_userScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.rating_userCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.rating_userScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.rating_userScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.rating_userGroupByOutput']:
        """Group rating_user records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar rating_user fields to group records by
        where
            rating_user filter to select records
        take
            Limit the maximum number of rating_user records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.rating_userGroupByOutput]
            A list of dictionaries representing the rating_user record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group rating_user records by job_id values
        # and count how many records are in each group
        results = rating_user.prisma().group_by(
            ['job_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class rating_comActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.rating_com]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = rating_com.prisma().query_raw(
            'SELECT * FROM rating_com WHERE rating_id = $1',
            1627576247,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.rating_com
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = rating_com.prisma().query_first(
            'SELECT * FROM rating_com WHERE job_id = $1',
            2054802212,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.rating_comCreateInput,
        include: Optional[types.rating_comInclude] = None
    ) -> _PrismaModelT:
        """Create a new rating_com record.

        Parameters
        ----------
        data
            rating_com record data
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The created rating_com record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a rating_com record from just the required fields
        rating_com = rating_com.prisma().create(
            data={
                # data to create a rating_com record
                'job_id': 60335757,
                'user_id1': 684462146,
                'user_id2': 1625503827,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.rating_comCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple rating_com records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of rating_com record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = rating_com.prisma().create_many(
            data=[
                {
                    # data to create a rating_com record
                    'job_id': 521827728,
                    'user_id1': 1266032265,
                    'user_id2': 93253262,
                },
                {
                    # data to create a rating_com record
                    'job_id': 2053047983,
                    'user_id1': 685333180,
                    'user_id2': 127474245,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.rating_comWhereUniqueInput,
        include: Optional[types.rating_comInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single rating_com record.

        Parameters
        ----------
        where
            rating_com filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The deleted rating_com record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_com = rating_com.prisma().delete(
            where={
                'rating_id': 948921754,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.rating_comWhereUniqueInput,
        include: Optional[types.rating_comInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique rating_com record.

        Parameters
        ----------
        where
            rating_com filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The found rating_com record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_com = rating_com.prisma().find_unique(
            where={
                'rating_id': 1964990155,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.rating_comWhereUniqueInput,
        include: Optional[types.rating_comInclude] = None
    ) -> _PrismaModelT:
        """Find a unique rating_com record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            rating_com filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The found rating_com record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_com = rating_com.prisma().find_unique_or_raise(
            where={
                'rating_id': 1228891816,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
        include: Optional[types.rating_comInclude] = None,
        order: Optional[Union[types.rating_comOrderByInput, List[types.rating_comOrderByInput]]] = None,
        distinct: Optional[List[types.rating_comScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple rating_com records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of rating_com records returned
        skip
            Ignore the first N results
        where
            rating_com filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_com model
        order
            Order the returned rating_com records by any field
        distinct
            Filter rating_com records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.rating_com]
            The list of all rating_com records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 rating_com records
        rating_coms = rating_com.prisma().find_many(take=10)

        # find the first 5 rating_com records ordered by the rating field
        rating_coms = rating_com.prisma().find_many(
            take=5,
            order={
                'rating': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
        include: Optional[types.rating_comInclude] = None,
        order: Optional[Union[types.rating_comOrderByInput, List[types.rating_comOrderByInput]]] = None,
        distinct: Optional[List[types.rating_comScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single rating_com record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            rating_com filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_com model
        order
            Order the returned rating_com records by any field
        distinct
            Filter rating_com records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.rating_com
            The first rating_com record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second rating_com record ordered by the user_id1 field
        rating_com = rating_com.prisma().find_first(
            skip=1,
            order={
                'user_id1': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
        include: Optional[types.rating_comInclude] = None,
        order: Optional[Union[types.rating_comOrderByInput, List[types.rating_comOrderByInput]]] = None,
        distinct: Optional[List[types.rating_comScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single rating_com record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            rating_com filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned rating_com model
        order
            Order the returned rating_com records by any field
        distinct
            Filter rating_com records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.rating_com
            The first rating_com record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second rating_com record ordered by the user_id2 field
        rating_com = rating_com.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id2': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.rating_comUpdateInput,
        where: types.rating_comWhereUniqueInput,
        include: Optional[types.rating_comInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single rating_com record.

        Parameters
        ----------
        data
            rating_com record data specifying what to update
        where
            rating_com filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The updated rating_com record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        rating_com = rating_com.prisma().update(
            where={
                'rating_id': 255202753,
            },
            data={
                # data to update the rating_com record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.rating_comWhereUniqueInput,
        data: types.rating_comUpsertInput,
        include: Optional[types.rating_comInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            rating_com filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned rating_com model

        Returns
        -------
        prisma.models.rating_com
            The created or updated rating_com record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        rating_com = rating_com.prisma().upsert(
            where={
                'rating_id': 1223573862,
            },
            data={
                'create': {
                    'rating_id': 1223573862,
                    'job_id': 2053047983,
                    'user_id1': 685333180,
                    'user_id2': 127474245,
                },
                'update': {
                    'job_id': 2053047983,
                    'user_id1': 685333180,
                    'user_id2': 127474245,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.rating_comUpdateManyMutationInput,
        where: types.rating_comWhereInput,
    ) -> int:
        """Update multiple rating_com records

        Parameters
        ----------
        data
            rating_com data to update the selected rating_com records to
        where
            Filter to select the rating_com records to update

        Returns
        -------
        int
            The total number of rating_com records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all rating_com records
        total = rating_com.prisma().update_many(
            data={
                'rating_id': 541269159
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
    ) -> int:
        """Count the number of rating_com records present in the database

        Parameters
        ----------
        select
            Select the rating_com fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            rating_com filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.rating_comCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = rating_com.prisma().count()

        # results: prisma.types.rating_comCountAggregateOutput
        results = rating_com.prisma().count(
            select={
                '_all': True,
                'job_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.rating_comCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
    ) -> types.rating_comCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.rating_comCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.rating_comWhereInput] = None,
        cursor: Optional[types.rating_comWhereUniqueInput] = None,
    ) -> Union[int, types.rating_comCountAggregateOutput]:
        """Count the number of rating_com records present in the database

        Parameters
        ----------
        select
            Select the rating_com fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            rating_com filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.rating_comCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = rating_com.prisma().count()

        # results: prisma.types.rating_comCountAggregateOutput
        results = rating_com.prisma().count(
            select={
                '_all': True,
                'rating': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.rating_comCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.rating_comWhereInput] = None
    ) -> int:
        """Delete multiple rating_com records.

        Parameters
        ----------
        where
            Optional rating_com filter to find the records to be deleted

        Returns
        -------
        int
            The total number of rating_com records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all rating_com records
        total = rating_com.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.rating_comScalarFieldKeys'],
        *,
        where: Optional['types.rating_comWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.rating_comAvgAggregateInput'] = None,
        sum: Optional['types.rating_comSumAggregateInput'] = None,
        min: Optional['types.rating_comMinAggregateInput'] = None,
        max: Optional['types.rating_comMaxAggregateInput'] = None,
        having: Optional['types.rating_comScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.rating_comCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.rating_comScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.rating_comScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.rating_comGroupByOutput']:
        """Group rating_com records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar rating_com fields to group records by
        where
            rating_com filter to select records
        take
            Limit the maximum number of rating_com records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.rating_comGroupByOutput]
            A list of dictionaries representing the rating_com record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group rating_com records by user_id1 values
        # and count how many records are in each group
        results = rating_com.prisma().group_by(
            ['user_id1'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class contactActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.contact]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = contact.prisma().query_raw(
            'SELECT * FROM contact WHERE contact_id = $1',
            1064846676,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.contact
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = contact.prisma().query_first(
            'SELECT * FROM contact WHERE user_id = $1',
            508382461,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.contactCreateInput,
        include: Optional[types.contactInclude] = None
    ) -> _PrismaModelT:
        """Create a new contact record.

        Parameters
        ----------
        data
            contact record data
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The created contact record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a contact record from just the required fields
        contact = contact.prisma().create(
            data={
                # data to create a contact record
                'user_id': 1024265714,
                'facebook': 'ihcahiead',
                'instagram': 'biheheiajg',
                'linkedin': 'jbgijghgb',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.contactCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple contact records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of contact record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = contact.prisma().create_many(
            data=[
                {
                    # data to create a contact record
                    'user_id': 769267518,
                    'facebook': 'icadbcehj',
                    'instagram': 'jchciaee',
                    'linkedin': 'deeificjd',
                },
                {
                    # data to create a contact record
                    'user_id': 1121741130,
                    'facebook': 'bejfijgcfb',
                    'instagram': 'caifcbgii',
                    'linkedin': 'igaibbfgj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.contactWhereUniqueInput,
        include: Optional[types.contactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single contact record.

        Parameters
        ----------
        where
            contact filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The deleted contact record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = contact.prisma().delete(
            where={
                'contact_id': 1660932118,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.contactWhereUniqueInput,
        include: Optional[types.contactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique contact record.

        Parameters
        ----------
        where
            contact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The found contact record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = contact.prisma().find_unique(
            where={
                'contact_id': 525761943,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.contactWhereUniqueInput,
        include: Optional[types.contactInclude] = None
    ) -> _PrismaModelT:
        """Find a unique contact record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            contact filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The found contact record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = contact.prisma().find_unique_or_raise(
            where={
                'contact_id': 736209796,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
        include: Optional[types.contactInclude] = None,
        order: Optional[Union[types.contactOrderByInput, List[types.contactOrderByInput]]] = None,
        distinct: Optional[List[types.contactScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple contact records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of contact records returned
        skip
            Ignore the first N results
        where
            contact filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned contact model
        order
            Order the returned contact records by any field
        distinct
            Filter contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.contact]
            The list of all contact records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 contact records
        contacts = contact.prisma().find_many(take=10)

        # find the first 5 contact records ordered by the facebook field
        contacts = contact.prisma().find_many(
            take=5,
            order={
                'facebook': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
        include: Optional[types.contactInclude] = None,
        order: Optional[Union[types.contactOrderByInput, List[types.contactOrderByInput]]] = None,
        distinct: Optional[List[types.contactScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single contact record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            contact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned contact model
        order
            Order the returned contact records by any field
        distinct
            Filter contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.contact
            The first contact record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second contact record ordered by the instagram field
        contact = contact.prisma().find_first(
            skip=1,
            order={
                'instagram': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
        include: Optional[types.contactInclude] = None,
        order: Optional[Union[types.contactOrderByInput, List[types.contactOrderByInput]]] = None,
        distinct: Optional[List[types.contactScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single contact record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            contact filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned contact model
        order
            Order the returned contact records by any field
        distinct
            Filter contact records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.contact
            The first contact record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second contact record ordered by the linkedin field
        contact = contact.prisma().find_first_or_raise(
            skip=1,
            order={
                'linkedin': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.contactUpdateInput,
        where: types.contactWhereUniqueInput,
        include: Optional[types.contactInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single contact record.

        Parameters
        ----------
        data
            contact record data specifying what to update
        where
            contact filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The updated contact record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        contact = contact.prisma().update(
            where={
                'contact_id': 493907821,
            },
            data={
                # data to update the contact record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.contactWhereUniqueInput,
        data: types.contactUpsertInput,
        include: Optional[types.contactInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            contact filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned contact model

        Returns
        -------
        prisma.models.contact
            The created or updated contact record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        contact = contact.prisma().upsert(
            where={
                'contact_id': 639686562,
            },
            data={
                'create': {
                    'contact_id': 639686562,
                    'user_id': 1121741130,
                    'facebook': 'bejfijgcfb',
                    'instagram': 'caifcbgii',
                    'linkedin': 'igaibbfgj',
                },
                'update': {
                    'user_id': 1121741130,
                    'facebook': 'bejfijgcfb',
                    'instagram': 'caifcbgii',
                    'linkedin': 'igaibbfgj',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.contactUpdateManyMutationInput,
        where: types.contactWhereInput,
    ) -> int:
        """Update multiple contact records

        Parameters
        ----------
        data
            contact data to update the selected contact records to
        where
            Filter to select the contact records to update

        Returns
        -------
        int
            The total number of contact records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all contact records
        total = contact.prisma().update_many(
            data={
                'contact_id': 654007347
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
    ) -> int:
        """Count the number of contact records present in the database

        Parameters
        ----------
        select
            Select the contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.contactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = contact.prisma().count()

        # results: prisma.types.contactCountAggregateOutput
        results = contact.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.contactCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
    ) -> types.contactCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.contactCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.contactWhereInput] = None,
        cursor: Optional[types.contactWhereUniqueInput] = None,
    ) -> Union[int, types.contactCountAggregateOutput]:
        """Count the number of contact records present in the database

        Parameters
        ----------
        select
            Select the contact fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            contact filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.contactCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = contact.prisma().count()

        # results: prisma.types.contactCountAggregateOutput
        results = contact.prisma().count(
            select={
                '_all': True,
                'facebook': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.contactCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.contactWhereInput] = None
    ) -> int:
        """Delete multiple contact records.

        Parameters
        ----------
        where
            Optional contact filter to find the records to be deleted

        Returns
        -------
        int
            The total number of contact records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all contact records
        total = contact.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.contactScalarFieldKeys'],
        *,
        where: Optional['types.contactWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.contactAvgAggregateInput'] = None,
        sum: Optional['types.contactSumAggregateInput'] = None,
        min: Optional['types.contactMinAggregateInput'] = None,
        max: Optional['types.contactMaxAggregateInput'] = None,
        having: Optional['types.contactScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.contactCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.contactScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.contactScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.contactGroupByOutput']:
        """Group contact records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar contact fields to group records by
        where
            contact filter to select records
        take
            Limit the maximum number of contact records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.contactGroupByOutput]
            A list of dictionaries representing the contact record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group contact records by instagram values
        # and count how many records are in each group
        results = contact.prisma().group_by(
            ['instagram'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class categoryActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.category]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = category.prisma().query_raw(
            'SELECT * FROM category WHERE category_id = $1',
            1905261552,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.category
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = category.prisma().query_first(
            'SELECT * FROM category WHERE name = $1',
            'hihegjif',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.categoryCreateInput,
        include: Optional[types.categoryInclude] = None
    ) -> _PrismaModelT:
        """Create a new category record.

        Parameters
        ----------
        data
            category record data
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The created category record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a category record from just the required fields
        category = category.prisma().create(
            data={
                # data to create a category record
                'name': 'bdjidcidac',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.categoryCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple category records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of category record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = category.prisma().create_many(
            data=[
                {
                    # data to create a category record
                    'name': 'ifgaaagff',
                },
                {
                    # data to create a category record
                    'name': 'befcddgjce',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.categoryWhereUniqueInput,
        include: Optional[types.categoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single category record.

        Parameters
        ----------
        where
            category filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The deleted category record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = category.prisma().delete(
            where={
                'category_id': 1573199653,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.categoryWhereUniqueInput,
        include: Optional[types.categoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique category record.

        Parameters
        ----------
        where
            category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The found category record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = category.prisma().find_unique(
            where={
                'category_id': 2013903098,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.categoryWhereUniqueInput,
        include: Optional[types.categoryInclude] = None
    ) -> _PrismaModelT:
        """Find a unique category record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            category filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The found category record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = category.prisma().find_unique_or_raise(
            where={
                'category_id': 500965035,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
        include: Optional[types.categoryInclude] = None,
        order: Optional[Union[types.categoryOrderByInput, List[types.categoryOrderByInput]]] = None,
        distinct: Optional[List[types.categoryScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple category records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of category records returned
        skip
            Ignore the first N results
        where
            category filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned category model
        order
            Order the returned category records by any field
        distinct
            Filter category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.category]
            The list of all category records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 category records
        categorys = category.prisma().find_many(take=10)

        # find the first 5 category records ordered by the category_id field
        categorys = category.prisma().find_many(
            take=5,
            order={
                'category_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
        include: Optional[types.categoryInclude] = None,
        order: Optional[Union[types.categoryOrderByInput, List[types.categoryOrderByInput]]] = None,
        distinct: Optional[List[types.categoryScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single category record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned category model
        order
            Order the returned category records by any field
        distinct
            Filter category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.category
            The first category record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second category record ordered by the name field
        category = category.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
        include: Optional[types.categoryInclude] = None,
        order: Optional[Union[types.categoryOrderByInput, List[types.categoryOrderByInput]]] = None,
        distinct: Optional[List[types.categoryScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single category record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            category filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned category model
        order
            Order the returned category records by any field
        distinct
            Filter category records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.category
            The first category record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second category record ordered by the category_id field
        category = category.prisma().find_first_or_raise(
            skip=1,
            order={
                'category_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.categoryUpdateInput,
        where: types.categoryWhereUniqueInput,
        include: Optional[types.categoryInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single category record.

        Parameters
        ----------
        data
            category record data specifying what to update
        where
            category filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The updated category record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        category = category.prisma().update(
            where={
                'category_id': 1800624392,
            },
            data={
                # data to update the category record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.categoryWhereUniqueInput,
        data: types.categoryUpsertInput,
        include: Optional[types.categoryInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            category filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned category model

        Returns
        -------
        prisma.models.category
            The created or updated category record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        category = category.prisma().upsert(
            where={
                'category_id': 2077067425,
            },
            data={
                'create': {
                    'category_id': 2077067425,
                    'name': 'befcddgjce',
                },
                'update': {
                    'name': 'befcddgjce',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.categoryUpdateManyMutationInput,
        where: types.categoryWhereInput,
    ) -> int:
        """Update multiple category records

        Parameters
        ----------
        data
            category data to update the selected category records to
        where
            Filter to select the category records to update

        Returns
        -------
        int
            The total number of category records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all category records
        total = category.prisma().update_many(
            data={
                'name': 'bghcbbcidi'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
    ) -> int:
        """Count the number of category records present in the database

        Parameters
        ----------
        select
            Select the category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = category.prisma().count()

        # results: prisma.types.categoryCountAggregateOutput
        results = category.prisma().count(
            select={
                '_all': True,
                'category_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.categoryCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
    ) -> types.categoryCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.categoryCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.categoryWhereInput] = None,
        cursor: Optional[types.categoryWhereUniqueInput] = None,
    ) -> Union[int, types.categoryCountAggregateOutput]:
        """Count the number of category records present in the database

        Parameters
        ----------
        select
            Select the category fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            category filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.categoryCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = category.prisma().count()

        # results: prisma.types.categoryCountAggregateOutput
        results = category.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.categoryCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.categoryWhereInput] = None
    ) -> int:
        """Delete multiple category records.

        Parameters
        ----------
        where
            Optional category filter to find the records to be deleted

        Returns
        -------
        int
            The total number of category records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all category records
        total = category.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.categoryScalarFieldKeys'],
        *,
        where: Optional['types.categoryWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.categoryAvgAggregateInput'] = None,
        sum: Optional['types.categorySumAggregateInput'] = None,
        min: Optional['types.categoryMinAggregateInput'] = None,
        max: Optional['types.categoryMaxAggregateInput'] = None,
        having: Optional['types.categoryScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.categoryCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.categoryScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.categoryScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.categoryGroupByOutput']:
        """Group category records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar category fields to group records by
        where
            category filter to select records
        take
            Limit the maximum number of category records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.categoryGroupByOutput]
            A list of dictionaries representing the category record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group category records by category_id values
        # and count how many records are in each group
        results = category.prisma().group_by(
            ['category_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class experienceActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.experience]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = experience.prisma().query_raw(
            'SELECT * FROM experience WHERE user_id = $1',
            926677639,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.experience
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = experience.prisma().query_first(
            'SELECT * FROM experience WHERE category_id = $1',
            1447624116,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.experienceCreateInput,
        include: Optional[types.experienceInclude] = None
    ) -> _PrismaModelT:
        """Create a new experience record.

        Parameters
        ----------
        data
            experience record data
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The created experience record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a experience record from just the required fields
        experience = experience.prisma().create(
            data={
                # data to create a experience record
                'user_id': 1738083805,
                'category_id': 340946258,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.experienceCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple experience records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of experience record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = experience.prisma().create_many(
            data=[
                {
                    # data to create a experience record
                    'user_id': 601077795,
                    'category_id': 290603296,
                },
                {
                    # data to create a experience record
                    'user_id': 1855826649,
                    'category_id': 1611009182,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.experienceWhereUniqueInput,
        include: Optional[types.experienceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single experience record.

        Parameters
        ----------
        where
            experience filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The deleted experience record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        experience = experience.prisma().delete(
            where={
                # experience where unique filter

            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.experienceWhereUniqueInput,
        include: Optional[types.experienceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique experience record.

        Parameters
        ----------
        where
            experience filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The found experience record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        experience = experience.prisma().find_unique(
            where={
                # experience where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.experienceWhereUniqueInput,
        include: Optional[types.experienceInclude] = None
    ) -> _PrismaModelT:
        """Find a unique experience record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            experience filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The found experience record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        experience = experience.prisma().find_unique_or_raise(
            where={
                # experience where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
        include: Optional[types.experienceInclude] = None,
        order: Optional[Union[types.experienceOrderByInput, List[types.experienceOrderByInput]]] = None,
        distinct: Optional[List[types.experienceScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple experience records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of experience records returned
        skip
            Ignore the first N results
        where
            experience filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned experience model
        order
            Order the returned experience records by any field
        distinct
            Filter experience records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.experience]
            The list of all experience records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 experience records
        experiences = experience.prisma().find_many(take=10)

        # find the first 5 experience records ordered by the user_id field
        experiences = experience.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
        include: Optional[types.experienceInclude] = None,
        order: Optional[Union[types.experienceOrderByInput, List[types.experienceOrderByInput]]] = None,
        distinct: Optional[List[types.experienceScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single experience record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            experience filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned experience model
        order
            Order the returned experience records by any field
        distinct
            Filter experience records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.experience
            The first experience record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second experience record ordered by the category_id field
        experience = experience.prisma().find_first(
            skip=1,
            order={
                'category_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
        include: Optional[types.experienceInclude] = None,
        order: Optional[Union[types.experienceOrderByInput, List[types.experienceOrderByInput]]] = None,
        distinct: Optional[List[types.experienceScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single experience record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            experience filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned experience model
        order
            Order the returned experience records by any field
        distinct
            Filter experience records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.experience
            The first experience record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second experience record ordered by the user_id field
        experience = experience.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.experienceUpdateInput,
        where: types.experienceWhereUniqueInput,
        include: Optional[types.experienceInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single experience record.

        Parameters
        ----------
        data
            experience record data specifying what to update
        where
            experience filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The updated experience record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        experience = experience.prisma().update(
            where={
                # experience where unique filter

            },
            data={
                # data to update the experience record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.experienceWhereUniqueInput,
        data: types.experienceUpsertInput,
        include: Optional[types.experienceInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            experience filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned experience model

        Returns
        -------
        prisma.models.experience
            The created or updated experience record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        experience = experience.prisma().upsert(
            where={
                # experience where unique filter
            },
            data={
                'create': {
                    # experience data to be set if the record does not exist
                },
                'update': {
                    # experience data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.experienceUpdateManyMutationInput,
        where: types.experienceWhereInput,
    ) -> int:
        """Update multiple experience records

        Parameters
        ----------
        data
            experience data to update the selected experience records to
        where
            Filter to select the experience records to update

        Returns
        -------
        int
            The total number of experience records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all experience records
        total = experience.prisma().update_many(
            data={
                'category_id': 446673791
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
    ) -> int:
        """Count the number of experience records present in the database

        Parameters
        ----------
        select
            Select the experience fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            experience filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.experienceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = experience.prisma().count()

        # results: prisma.types.experienceCountAggregateOutput
        results = experience.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.experienceCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
    ) -> types.experienceCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.experienceCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.experienceWhereInput] = None,
        cursor: Optional[types.experienceWhereUniqueInput] = None,
    ) -> Union[int, types.experienceCountAggregateOutput]:
        """Count the number of experience records present in the database

        Parameters
        ----------
        select
            Select the experience fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            experience filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.experienceCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = experience.prisma().count()

        # results: prisma.types.experienceCountAggregateOutput
        results = experience.prisma().count(
            select={
                '_all': True,
                'category_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.experienceCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.experienceWhereInput] = None
    ) -> int:
        """Delete multiple experience records.

        Parameters
        ----------
        where
            Optional experience filter to find the records to be deleted

        Returns
        -------
        int
            The total number of experience records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all experience records
        total = experience.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.experienceScalarFieldKeys'],
        *,
        where: Optional['types.experienceWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.experienceAvgAggregateInput'] = None,
        sum: Optional['types.experienceSumAggregateInput'] = None,
        min: Optional['types.experienceMinAggregateInput'] = None,
        max: Optional['types.experienceMaxAggregateInput'] = None,
        having: Optional['types.experienceScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.experienceCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.experienceScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.experienceScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.experienceGroupByOutput']:
        """Group experience records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar experience fields to group records by
        where
            experience filter to select records
        take
            Limit the maximum number of experience records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.experienceGroupByOutput]
            A list of dictionaries representing the experience record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group experience records by user_id values
        # and count how many records are in each group
        results = experience.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class careerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.career]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = career.prisma().query_raw(
            'SELECT * FROM career WHERE career_id = $1',
            300568396,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.career
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = career.prisma().query_first(
            'SELECT * FROM career WHERE name = $1',
            'gdcgcgagj',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.careerCreateInput,
        include: Optional[types.careerInclude] = None
    ) -> _PrismaModelT:
        """Create a new career record.

        Parameters
        ----------
        data
            career record data
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The created career record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a career record from just the required fields
        career = career.prisma().create(
            data={
                # data to create a career record
                'name': 'bhceabbgja',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.careerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple career records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of career record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = career.prisma().create_many(
            data=[
                {
                    # data to create a career record
                    'name': 'ehabfhegh',
                },
                {
                    # data to create a career record
                    'name': 'bcajcajjbc',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.careerWhereUniqueInput,
        include: Optional[types.careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single career record.

        Parameters
        ----------
        where
            career filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The deleted career record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        career = career.prisma().delete(
            where={
                'career_id': 1536744465,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.careerWhereUniqueInput,
        include: Optional[types.careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique career record.

        Parameters
        ----------
        where
            career filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The found career record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        career = career.prisma().find_unique(
            where={
                'career_id': 424218998,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.careerWhereUniqueInput,
        include: Optional[types.careerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique career record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            career filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The found career record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        career = career.prisma().find_unique_or_raise(
            where={
                'career_id': 2125632375,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
        include: Optional[types.careerInclude] = None,
        order: Optional[Union[types.careerOrderByInput, List[types.careerOrderByInput]]] = None,
        distinct: Optional[List[types.careerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple career records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of career records returned
        skip
            Ignore the first N results
        where
            career filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned career model
        order
            Order the returned career records by any field
        distinct
            Filter career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.career]
            The list of all career records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 career records
        careers = career.prisma().find_many(take=10)

        # find the first 5 career records ordered by the career_id field
        careers = career.prisma().find_many(
            take=5,
            order={
                'career_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
        include: Optional[types.careerInclude] = None,
        order: Optional[Union[types.careerOrderByInput, List[types.careerOrderByInput]]] = None,
        distinct: Optional[List[types.careerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single career record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            career filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned career model
        order
            Order the returned career records by any field
        distinct
            Filter career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.career
            The first career record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second career record ordered by the name field
        career = career.prisma().find_first(
            skip=1,
            order={
                'name': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
        include: Optional[types.careerInclude] = None,
        order: Optional[Union[types.careerOrderByInput, List[types.careerOrderByInput]]] = None,
        distinct: Optional[List[types.careerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single career record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            career filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned career model
        order
            Order the returned career records by any field
        distinct
            Filter career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.career
            The first career record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second career record ordered by the career_id field
        career = career.prisma().find_first_or_raise(
            skip=1,
            order={
                'career_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.careerUpdateInput,
        where: types.careerWhereUniqueInput,
        include: Optional[types.careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single career record.

        Parameters
        ----------
        data
            career record data specifying what to update
        where
            career filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The updated career record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        career = career.prisma().update(
            where={
                'career_id': 536951780,
            },
            data={
                # data to update the career record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.careerWhereUniqueInput,
        data: types.careerUpsertInput,
        include: Optional[types.careerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            career filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned career model

        Returns
        -------
        prisma.models.career
            The created or updated career record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        career = career.prisma().upsert(
            where={
                'career_id': 924723277,
            },
            data={
                'create': {
                    'career_id': 924723277,
                    'name': 'bcajcajjbc',
                },
                'update': {
                    'name': 'bcajcajjbc',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.careerUpdateManyMutationInput,
        where: types.careerWhereInput,
    ) -> int:
        """Update multiple career records

        Parameters
        ----------
        data
            career data to update the selected career records to
        where
            Filter to select the career records to update

        Returns
        -------
        int
            The total number of career records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all career records
        total = career.prisma().update_many(
            data={
                'name': 'bgcbjdhjcc'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of career records present in the database

        Parameters
        ----------
        select
            Select the career fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            career filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.careerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = career.prisma().count()

        # results: prisma.types.careerCountAggregateOutput
        results = career.prisma().count(
            select={
                '_all': True,
                'career_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.careerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
    ) -> types.careerCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.careerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.careerWhereInput] = None,
        cursor: Optional[types.careerWhereUniqueInput] = None,
    ) -> Union[int, types.careerCountAggregateOutput]:
        """Count the number of career records present in the database

        Parameters
        ----------
        select
            Select the career fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            career filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.careerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = career.prisma().count()

        # results: prisma.types.careerCountAggregateOutput
        results = career.prisma().count(
            select={
                '_all': True,
                'name': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.careerCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.careerWhereInput] = None
    ) -> int:
        """Delete multiple career records.

        Parameters
        ----------
        where
            Optional career filter to find the records to be deleted

        Returns
        -------
        int
            The total number of career records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all career records
        total = career.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.careerScalarFieldKeys'],
        *,
        where: Optional['types.careerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.careerAvgAggregateInput'] = None,
        sum: Optional['types.careerSumAggregateInput'] = None,
        min: Optional['types.careerMinAggregateInput'] = None,
        max: Optional['types.careerMaxAggregateInput'] = None,
        having: Optional['types.careerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.careerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.careerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.careerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.careerGroupByOutput']:
        """Group career records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar career fields to group records by
        where
            career filter to select records
        take
            Limit the maximum number of career records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.careerGroupByOutput]
            A list of dictionaries representing the career record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group career records by career_id values
        # and count how many records are in each group
        results = career.prisma().group_by(
            ['career_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class user_careerActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.user_career]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = user_career.prisma().query_raw(
            'SELECT * FROM user_career WHERE user_id = $1',
            1848832019,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.user_career
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = user_career.prisma().query_first(
            'SELECT * FROM user_career WHERE career_id = $1',
            1921528400,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.user_careerCreateInput,
        include: Optional[types.user_careerInclude] = None
    ) -> _PrismaModelT:
        """Create a new user_career record.

        Parameters
        ----------
        data
            user_career record data
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The created user_career record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a user_career record from just the required fields
        user_career = user_career.prisma().create(
            data={
                # data to create a user_career record
                'user_id': 2100427849,
                'career_id': 849140046,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.user_careerCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple user_career records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of user_career record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = user_career.prisma().create_many(
            data=[
                {
                    # data to create a user_career record
                    'user_id': 928152175,
                    'career_id': 273032060,
                },
                {
                    # data to create a user_career record
                    'user_id': 982848517,
                    'career_id': 510737498,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.user_careerWhereUniqueInput,
        include: Optional[types.user_careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single user_career record.

        Parameters
        ----------
        where
            user_career filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The deleted user_career record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_career = user_career.prisma().delete(
            where={
                # user_career where unique filter

            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.user_careerWhereUniqueInput,
        include: Optional[types.user_careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique user_career record.

        Parameters
        ----------
        where
            user_career filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The found user_career record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_career = user_career.prisma().find_unique(
            where={
                # user_career where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.user_careerWhereUniqueInput,
        include: Optional[types.user_careerInclude] = None
    ) -> _PrismaModelT:
        """Find a unique user_career record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            user_career filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The found user_career record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_career = user_career.prisma().find_unique_or_raise(
            where={
                # user_career where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
        include: Optional[types.user_careerInclude] = None,
        order: Optional[Union[types.user_careerOrderByInput, List[types.user_careerOrderByInput]]] = None,
        distinct: Optional[List[types.user_careerScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple user_career records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of user_career records returned
        skip
            Ignore the first N results
        where
            user_career filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_career model
        order
            Order the returned user_career records by any field
        distinct
            Filter user_career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.user_career]
            The list of all user_career records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 user_career records
        user_careers = user_career.prisma().find_many(take=10)

        # find the first 5 user_career records ordered by the user_id field
        user_careers = user_career.prisma().find_many(
            take=5,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
        include: Optional[types.user_careerInclude] = None,
        order: Optional[Union[types.user_careerOrderByInput, List[types.user_careerOrderByInput]]] = None,
        distinct: Optional[List[types.user_careerScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single user_career record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user_career filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_career model
        order
            Order the returned user_career records by any field
        distinct
            Filter user_career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user_career
            The first user_career record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user_career record ordered by the career_id field
        user_career = user_career.prisma().find_first(
            skip=1,
            order={
                'career_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
        include: Optional[types.user_careerInclude] = None,
        order: Optional[Union[types.user_careerOrderByInput, List[types.user_careerOrderByInput]]] = None,
        distinct: Optional[List[types.user_careerScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single user_career record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            user_career filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned user_career model
        order
            Order the returned user_career records by any field
        distinct
            Filter user_career records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.user_career
            The first user_career record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second user_career record ordered by the user_id field
        user_career = user_career.prisma().find_first_or_raise(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.user_careerUpdateInput,
        where: types.user_careerWhereUniqueInput,
        include: Optional[types.user_careerInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single user_career record.

        Parameters
        ----------
        data
            user_career record data specifying what to update
        where
            user_career filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The updated user_career record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user_career = user_career.prisma().update(
            where={
                # user_career where unique filter

            },
            data={
                # data to update the user_career record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.user_careerWhereUniqueInput,
        data: types.user_careerUpsertInput,
        include: Optional[types.user_careerInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            user_career filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned user_career model

        Returns
        -------
        prisma.models.user_career
            The created or updated user_career record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        user_career = user_career.prisma().upsert(
            where={
                # user_career where unique filter
            },
            data={
                'create': {
                    # user_career data to be set if the record does not exist
                },
                'update': {
                    # user_career data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.user_careerUpdateManyMutationInput,
        where: types.user_careerWhereInput,
    ) -> int:
        """Update multiple user_career records

        Parameters
        ----------
        data
            user_career data to update the selected user_career records to
        where
            Filter to select the user_career records to update

        Returns
        -------
        int
            The total number of user_career records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all user_career records
        total = user_career.prisma().update_many(
            data={
                'career_id': 2117488267
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
    ) -> int:
        """Count the number of user_career records present in the database

        Parameters
        ----------
        select
            Select the user_career fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user_career filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.user_careerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = user_career.prisma().count()

        # results: prisma.types.user_careerCountAggregateOutput
        results = user_career.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.user_careerCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
    ) -> types.user_careerCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.user_careerCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.user_careerWhereInput] = None,
        cursor: Optional[types.user_careerWhereUniqueInput] = None,
    ) -> Union[int, types.user_careerCountAggregateOutput]:
        """Count the number of user_career records present in the database

        Parameters
        ----------
        select
            Select the user_career fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            user_career filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.user_careerCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = user_career.prisma().count()

        # results: prisma.types.user_careerCountAggregateOutput
        results = user_career.prisma().count(
            select={
                '_all': True,
                'career_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.user_careerCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.user_careerWhereInput] = None
    ) -> int:
        """Delete multiple user_career records.

        Parameters
        ----------
        where
            Optional user_career filter to find the records to be deleted

        Returns
        -------
        int
            The total number of user_career records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all user_career records
        total = user_career.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.user_careerScalarFieldKeys'],
        *,
        where: Optional['types.user_careerWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.user_careerAvgAggregateInput'] = None,
        sum: Optional['types.user_careerSumAggregateInput'] = None,
        min: Optional['types.user_careerMinAggregateInput'] = None,
        max: Optional['types.user_careerMaxAggregateInput'] = None,
        having: Optional['types.user_careerScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.user_careerCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.user_careerScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.user_careerScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.user_careerGroupByOutput']:
        """Group user_career records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar user_career fields to group records by
        where
            user_career filter to select records
        take
            Limit the maximum number of user_career records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.user_careerGroupByOutput]
            A list of dictionaries representing the user_career record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group user_career records by user_id values
        # and count how many records are in each group
        results = user_career.prisma().group_by(
            ['user_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class jobActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.job]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = job.prisma().query_raw(
            'SELECT * FROM job WHERE job_id = $1',
            1401944936,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.job
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = job.prisma().query_first(
            'SELECT * FROM job WHERE title = $1',
            'bcjhgahffd',
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.jobCreateInput,
        include: Optional[types.jobInclude] = None
    ) -> _PrismaModelT:
        """Create a new job record.

        Parameters
        ----------
        data
            job record data
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The created job record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a job record from just the required fields
        job = job.prisma().create(
            data={
                # data to create a job record
                'title': 'fbjeiiffa',
                'description': 'jhgidcgbf',
                'budget': 1696425492,
                'type': 'bgjcgchib',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.jobCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple job records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of job record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = job.prisma().create_many(
            data=[
                {
                    # data to create a job record
                    'title': 'bacdaibgfa',
                    'description': 'dchgibach',
                    'budget': 527748992,
                    'type': 'cacjdfhejh',
                },
                {
                    # data to create a job record
                    'title': 'bdbifjhbbi',
                    'description': 'cbccbbcdfb',
                    'budget': 1024943020,
                    'type': 'bhbhdahfaj',
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.jobWhereUniqueInput,
        include: Optional[types.jobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single job record.

        Parameters
        ----------
        where
            job filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The deleted job record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = job.prisma().delete(
            where={
                'job_id': 1598124042,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.jobWhereUniqueInput,
        include: Optional[types.jobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique job record.

        Parameters
        ----------
        where
            job filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The found job record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = job.prisma().find_unique(
            where={
                'job_id': 817623163,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.jobWhereUniqueInput,
        include: Optional[types.jobInclude] = None
    ) -> _PrismaModelT:
        """Find a unique job record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            job filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The found job record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = job.prisma().find_unique_or_raise(
            where={
                'job_id': 1030557336,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
        include: Optional[types.jobInclude] = None,
        order: Optional[Union[types.jobOrderByInput, List[types.jobOrderByInput]]] = None,
        distinct: Optional[List[types.jobScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple job records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of job records returned
        skip
            Ignore the first N results
        where
            job filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job model
        order
            Order the returned job records by any field
        distinct
            Filter job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.job]
            The list of all job records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 job records
        jobs = job.prisma().find_many(take=10)

        # find the first 5 job records ordered by the description field
        jobs = job.prisma().find_many(
            take=5,
            order={
                'description': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
        include: Optional[types.jobInclude] = None,
        order: Optional[Union[types.jobOrderByInput, List[types.jobOrderByInput]]] = None,
        distinct: Optional[List[types.jobScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single job record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            job filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job model
        order
            Order the returned job records by any field
        distinct
            Filter job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.job
            The first job record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second job record ordered by the budget field
        job = job.prisma().find_first(
            skip=1,
            order={
                'budget': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
        include: Optional[types.jobInclude] = None,
        order: Optional[Union[types.jobOrderByInput, List[types.jobOrderByInput]]] = None,
        distinct: Optional[List[types.jobScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single job record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            job filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job model
        order
            Order the returned job records by any field
        distinct
            Filter job records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.job
            The first job record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second job record ordered by the type field
        job = job.prisma().find_first_or_raise(
            skip=1,
            order={
                'type': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.jobUpdateInput,
        where: types.jobWhereUniqueInput,
        include: Optional[types.jobInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single job record.

        Parameters
        ----------
        data
            job record data specifying what to update
        where
            job filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The updated job record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        job = job.prisma().update(
            where={
                'job_id': 1131525873,
            },
            data={
                # data to update the job record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.jobWhereUniqueInput,
        data: types.jobUpsertInput,
        include: Optional[types.jobInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            job filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned job model

        Returns
        -------
        prisma.models.job
            The created or updated job record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job = job.prisma().upsert(
            where={
                'job_id': 210666198,
            },
            data={
                'create': {
                    'job_id': 210666198,
                    'title': 'bdbifjhbbi',
                    'description': 'cbccbbcdfb',
                    'budget': 1024943020,
                    'type': 'bhbhdahfaj',
                },
                'update': {
                    'title': 'bdbifjhbbi',
                    'description': 'cbccbbcdfb',
                    'budget': 1024943020,
                    'type': 'bhbhdahfaj',
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.jobUpdateManyMutationInput,
        where: types.jobWhereInput,
    ) -> int:
        """Update multiple job records

        Parameters
        ----------
        data
            job data to update the selected job records to
        where
            Filter to select the job records to update

        Returns
        -------
        int
            The total number of job records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all job records
        total = job.prisma().update_many(
            data={
                'posted_date': datetime.datetime.utcnow()
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
    ) -> int:
        """Count the number of job records present in the database

        Parameters
        ----------
        select
            Select the job fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            job filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.jobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = job.prisma().count()

        # results: prisma.types.jobCountAggregateOutput
        results = job.prisma().count(
            select={
                '_all': True,
                'submitted_date': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.jobCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
    ) -> types.jobCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.jobCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.jobWhereInput] = None,
        cursor: Optional[types.jobWhereUniqueInput] = None,
    ) -> Union[int, types.jobCountAggregateOutput]:
        """Count the number of job records present in the database

        Parameters
        ----------
        select
            Select the job fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            job filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.jobCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = job.prisma().count()

        # results: prisma.types.jobCountAggregateOutput
        results = job.prisma().count(
            select={
                '_all': True,
                'status': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.jobCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.jobWhereInput] = None
    ) -> int:
        """Delete multiple job records.

        Parameters
        ----------
        where
            Optional job filter to find the records to be deleted

        Returns
        -------
        int
            The total number of job records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all job records
        total = job.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.jobScalarFieldKeys'],
        *,
        where: Optional['types.jobWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.jobAvgAggregateInput'] = None,
        sum: Optional['types.jobSumAggregateInput'] = None,
        min: Optional['types.jobMinAggregateInput'] = None,
        max: Optional['types.jobMaxAggregateInput'] = None,
        having: Optional['types.jobScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.jobCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.jobScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.jobScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.jobGroupByOutput']:
        """Group job records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar job fields to group records by
        where
            job filter to select records
        take
            Limit the maximum number of job records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.jobGroupByOutput]
            A list of dictionaries representing the job record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group job records by job_id values
        # and count how many records are in each group
        results = job.prisma().group_by(
            ['job_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class historyActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.history]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = history.prisma().query_raw(
            'SELECT * FROM history WHERE user_id = $1',
            1276057943,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.history
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = history.prisma().query_first(
            'SELECT * FROM history WHERE job_id = $1',
            745569348,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.historyCreateInput,
        include: Optional[types.historyInclude] = None
    ) -> _PrismaModelT:
        """Create a new history record.

        Parameters
        ----------
        data
            history record data
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The created history record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a history record from just the required fields
        history = history.prisma().create(
            data={
                # data to create a history record
                'user_id': 307876141,
                'job_id': 1674049122,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.historyCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple history records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of history record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = history.prisma().create_many(
            data=[
                {
                    # data to create a history record
                    'user_id': 1526854643,
                    'job_id': 958077104,
                },
                {
                    # data to create a history record
                    'user_id': 1513050921,
                    'job_id': 204674734,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.historyWhereUniqueInput,
        include: Optional[types.historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single history record.

        Parameters
        ----------
        where
            history filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The deleted history record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = history.prisma().delete(
            where={
                # history where unique filter

            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.historyWhereUniqueInput,
        include: Optional[types.historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique history record.

        Parameters
        ----------
        where
            history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The found history record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = history.prisma().find_unique(
            where={
                # history where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.historyWhereUniqueInput,
        include: Optional[types.historyInclude] = None
    ) -> _PrismaModelT:
        """Find a unique history record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            history filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The found history record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = history.prisma().find_unique_or_raise(
            where={
                # history where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
        include: Optional[types.historyInclude] = None,
        order: Optional[Union[types.historyOrderByInput, List[types.historyOrderByInput]]] = None,
        distinct: Optional[List[types.historyScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple history records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of history records returned
        skip
            Ignore the first N results
        where
            history filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned history model
        order
            Order the returned history records by any field
        distinct
            Filter history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.history]
            The list of all history records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 history records
        historys = history.prisma().find_many(take=10)

        # find the first 5 history records ordered by the status field
        historys = history.prisma().find_many(
            take=5,
            order={
                'status': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
        include: Optional[types.historyInclude] = None,
        order: Optional[Union[types.historyOrderByInput, List[types.historyOrderByInput]]] = None,
        distinct: Optional[List[types.historyScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single history record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned history model
        order
            Order the returned history records by any field
        distinct
            Filter history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.history
            The first history record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second history record ordered by the user_id field
        history = history.prisma().find_first(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
        include: Optional[types.historyInclude] = None,
        order: Optional[Union[types.historyOrderByInput, List[types.historyOrderByInput]]] = None,
        distinct: Optional[List[types.historyScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single history record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            history filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned history model
        order
            Order the returned history records by any field
        distinct
            Filter history records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.history
            The first history record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second history record ordered by the job_id field
        history = history.prisma().find_first_or_raise(
            skip=1,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.historyUpdateInput,
        where: types.historyWhereUniqueInput,
        include: Optional[types.historyInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single history record.

        Parameters
        ----------
        data
            history record data specifying what to update
        where
            history filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The updated history record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        history = history.prisma().update(
            where={
                # history where unique filter

            },
            data={
                # data to update the history record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.historyWhereUniqueInput,
        data: types.historyUpsertInput,
        include: Optional[types.historyInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            history filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned history model

        Returns
        -------
        prisma.models.history
            The created or updated history record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        history = history.prisma().upsert(
            where={
                # history where unique filter
            },
            data={
                'create': {
                    # history data to be set if the record does not exist
                },
                'update': {
                    # history data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.historyUpdateManyMutationInput,
        where: types.historyWhereInput,
    ) -> int:
        """Update multiple history records

        Parameters
        ----------
        data
            history data to update the selected history records to
        where
            Filter to select the history records to update

        Returns
        -------
        int
            The total number of history records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all history records
        total = history.prisma().update_many(
            data={
                'status': 'caghgfbggd'
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
    ) -> int:
        """Count the number of history records present in the database

        Parameters
        ----------
        select
            Select the history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = history.prisma().count()

        # results: prisma.types.historyCountAggregateOutput
        results = history.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.historyCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
    ) -> types.historyCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.historyCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.historyWhereInput] = None,
        cursor: Optional[types.historyWhereUniqueInput] = None,
    ) -> Union[int, types.historyCountAggregateOutput]:
        """Count the number of history records present in the database

        Parameters
        ----------
        select
            Select the history fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            history filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.historyCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = history.prisma().count()

        # results: prisma.types.historyCountAggregateOutput
        results = history.prisma().count(
            select={
                '_all': True,
                'job_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.historyCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.historyWhereInput] = None
    ) -> int:
        """Delete multiple history records.

        Parameters
        ----------
        where
            Optional history filter to find the records to be deleted

        Returns
        -------
        int
            The total number of history records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all history records
        total = history.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.historyScalarFieldKeys'],
        *,
        where: Optional['types.historyWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.historyAvgAggregateInput'] = None,
        sum: Optional['types.historySumAggregateInput'] = None,
        min: Optional['types.historyMinAggregateInput'] = None,
        max: Optional['types.historyMaxAggregateInput'] = None,
        having: Optional['types.historyScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.historyCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.historyScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.historyScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.historyGroupByOutput']:
        """Group history records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar history fields to group records by
        where
            history filter to select records
        take
            Limit the maximum number of history records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.historyGroupByOutput]
            A list of dictionaries representing the history record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group history records by status values
        # and count how many records are in each group
        results = history.prisma().group_by(
            ['status'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class job_expActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.job_exp]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = job_exp.prisma().query_raw(
            'SELECT * FROM job_exp WHERE job_id = $1',
            1183911900,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.job_exp
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = job_exp.prisma().query_first(
            'SELECT * FROM job_exp WHERE category_id = $1',
            1589704933,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.job_expCreateInput,
        include: Optional[types.job_expInclude] = None
    ) -> _PrismaModelT:
        """Create a new job_exp record.

        Parameters
        ----------
        data
            job_exp record data
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The created job_exp record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a job_exp record from just the required fields
        job_exp = job_exp.prisma().create(
            data={
                # data to create a job_exp record
                'job_id': 1243475898,
                'category_id': 1369828971,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.job_expCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple job_exp records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of job_exp record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = job_exp.prisma().create_many(
            data=[
                {
                    # data to create a job_exp record
                    'job_id': 1678593480,
                    'category_id': 403521121,
                },
                {
                    # data to create a job_exp record
                    'job_id': 648760710,
                    'category_id': 607323719,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.job_expWhereUniqueInput,
        include: Optional[types.job_expInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single job_exp record.

        Parameters
        ----------
        where
            job_exp filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The deleted job_exp record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job_exp = job_exp.prisma().delete(
            where={
                # job_exp where unique filter

            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.job_expWhereUniqueInput,
        include: Optional[types.job_expInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique job_exp record.

        Parameters
        ----------
        where
            job_exp filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The found job_exp record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job_exp = job_exp.prisma().find_unique(
            where={
                # job_exp where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.job_expWhereUniqueInput,
        include: Optional[types.job_expInclude] = None
    ) -> _PrismaModelT:
        """Find a unique job_exp record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            job_exp filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The found job_exp record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job_exp = job_exp.prisma().find_unique_or_raise(
            where={
                # job_exp where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
        include: Optional[types.job_expInclude] = None,
        order: Optional[Union[types.job_expOrderByInput, List[types.job_expOrderByInput]]] = None,
        distinct: Optional[List[types.job_expScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple job_exp records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of job_exp records returned
        skip
            Ignore the first N results
        where
            job_exp filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job_exp model
        order
            Order the returned job_exp records by any field
        distinct
            Filter job_exp records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.job_exp]
            The list of all job_exp records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 job_exp records
        job_exps = job_exp.prisma().find_many(take=10)

        # find the first 5 job_exp records ordered by the job_id field
        job_exps = job_exp.prisma().find_many(
            take=5,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
        include: Optional[types.job_expInclude] = None,
        order: Optional[Union[types.job_expOrderByInput, List[types.job_expOrderByInput]]] = None,
        distinct: Optional[List[types.job_expScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single job_exp record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            job_exp filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job_exp model
        order
            Order the returned job_exp records by any field
        distinct
            Filter job_exp records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.job_exp
            The first job_exp record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second job_exp record ordered by the category_id field
        job_exp = job_exp.prisma().find_first(
            skip=1,
            order={
                'category_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
        include: Optional[types.job_expInclude] = None,
        order: Optional[Union[types.job_expOrderByInput, List[types.job_expOrderByInput]]] = None,
        distinct: Optional[List[types.job_expScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single job_exp record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            job_exp filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned job_exp model
        order
            Order the returned job_exp records by any field
        distinct
            Filter job_exp records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.job_exp
            The first job_exp record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second job_exp record ordered by the job_id field
        job_exp = job_exp.prisma().find_first_or_raise(
            skip=1,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.job_expUpdateInput,
        where: types.job_expWhereUniqueInput,
        include: Optional[types.job_expInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single job_exp record.

        Parameters
        ----------
        data
            job_exp record data specifying what to update
        where
            job_exp filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The updated job_exp record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        job_exp = job_exp.prisma().update(
            where={
                # job_exp where unique filter

            },
            data={
                # data to update the job_exp record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.job_expWhereUniqueInput,
        data: types.job_expUpsertInput,
        include: Optional[types.job_expInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            job_exp filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned job_exp model

        Returns
        -------
        prisma.models.job_exp
            The created or updated job_exp record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        job_exp = job_exp.prisma().upsert(
            where={
                # job_exp where unique filter
            },
            data={
                'create': {
                    # job_exp data to be set if the record does not exist
                },
                'update': {
                    # job_exp data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.job_expUpdateManyMutationInput,
        where: types.job_expWhereInput,
    ) -> int:
        """Update multiple job_exp records

        Parameters
        ----------
        data
            job_exp data to update the selected job_exp records to
        where
            Filter to select the job_exp records to update

        Returns
        -------
        int
            The total number of job_exp records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all job_exp records
        total = job_exp.prisma().update_many(
            data={
                'category_id': 1468890740
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
    ) -> int:
        """Count the number of job_exp records present in the database

        Parameters
        ----------
        select
            Select the job_exp fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            job_exp filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.job_expCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = job_exp.prisma().count()

        # results: prisma.types.job_expCountAggregateOutput
        results = job_exp.prisma().count(
            select={
                '_all': True,
                'job_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.job_expCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
    ) -> types.job_expCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.job_expCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.job_expWhereInput] = None,
        cursor: Optional[types.job_expWhereUniqueInput] = None,
    ) -> Union[int, types.job_expCountAggregateOutput]:
        """Count the number of job_exp records present in the database

        Parameters
        ----------
        select
            Select the job_exp fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            job_exp filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.job_expCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = job_exp.prisma().count()

        # results: prisma.types.job_expCountAggregateOutput
        results = job_exp.prisma().count(
            select={
                '_all': True,
                'category_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.job_expCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.job_expWhereInput] = None
    ) -> int:
        """Delete multiple job_exp records.

        Parameters
        ----------
        where
            Optional job_exp filter to find the records to be deleted

        Returns
        -------
        int
            The total number of job_exp records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all job_exp records
        total = job_exp.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.job_expScalarFieldKeys'],
        *,
        where: Optional['types.job_expWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.job_expAvgAggregateInput'] = None,
        sum: Optional['types.job_expSumAggregateInput'] = None,
        min: Optional['types.job_expMinAggregateInput'] = None,
        max: Optional['types.job_expMaxAggregateInput'] = None,
        having: Optional['types.job_expScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.job_expCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.job_expScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.job_expScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.job_expGroupByOutput']:
        """Group job_exp records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar job_exp fields to group records by
        where
            job_exp filter to select records
        take
            Limit the maximum number of job_exp records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.job_expGroupByOutput]
            A list of dictionaries representing the job_exp record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group job_exp records by job_id values
        # and count how many records are in each group
        results = job_exp.prisma().group_by(
            ['job_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class bookmarkActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.bookmark]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = bookmark.prisma().query_raw(
            'SELECT * FROM bookmark WHERE user_id = $1',
            629039005,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.bookmark
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = bookmark.prisma().query_first(
            'SELECT * FROM bookmark WHERE job_id = $1',
            1214168082,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.bookmarkCreateInput,
        include: Optional[types.bookmarkInclude] = None
    ) -> _PrismaModelT:
        """Create a new bookmark record.

        Parameters
        ----------
        data
            bookmark record data
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The created bookmark record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a bookmark record from just the required fields
        bookmark = bookmark.prisma().create(
            data={
                # data to create a bookmark record
                'user_id': 898613219,
                'job_id': 658378208,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.bookmarkCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple bookmark records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of bookmark record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = bookmark.prisma().create_many(
            data=[
                {
                    # data to create a bookmark record
                    'user_id': 954620057,
                    'job_id': 1214809950,
                },
                {
                    # data to create a bookmark record
                    'user_id': 1047820095,
                    'job_id': 1302734860,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.bookmarkWhereUniqueInput,
        include: Optional[types.bookmarkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single bookmark record.

        Parameters
        ----------
        where
            bookmark filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The deleted bookmark record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark = bookmark.prisma().delete(
            where={
                'book_id': 893052245,
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.bookmarkWhereUniqueInput,
        include: Optional[types.bookmarkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique bookmark record.

        Parameters
        ----------
        where
            bookmark filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The found bookmark record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark = bookmark.prisma().find_unique(
            where={
                'book_id': 280083306,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.bookmarkWhereUniqueInput,
        include: Optional[types.bookmarkInclude] = None
    ) -> _PrismaModelT:
        """Find a unique bookmark record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            bookmark filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The found bookmark record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark = bookmark.prisma().find_unique_or_raise(
            where={
                'book_id': 549668955,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
        include: Optional[types.bookmarkInclude] = None,
        order: Optional[Union[types.bookmarkOrderByInput, List[types.bookmarkOrderByInput]]] = None,
        distinct: Optional[List[types.bookmarkScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple bookmark records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of bookmark records returned
        skip
            Ignore the first N results
        where
            bookmark filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark model
        order
            Order the returned bookmark records by any field
        distinct
            Filter bookmark records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.bookmark]
            The list of all bookmark records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 bookmark records
        bookmarks = bookmark.prisma().find_many(take=10)

        # find the first 5 bookmark records ordered by the book_id field
        bookmarks = bookmark.prisma().find_many(
            take=5,
            order={
                'book_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
        include: Optional[types.bookmarkInclude] = None,
        order: Optional[Union[types.bookmarkOrderByInput, List[types.bookmarkOrderByInput]]] = None,
        distinct: Optional[List[types.bookmarkScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single bookmark record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            bookmark filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark model
        order
            Order the returned bookmark records by any field
        distinct
            Filter bookmark records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.bookmark
            The first bookmark record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second bookmark record ordered by the user_id field
        bookmark = bookmark.prisma().find_first(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
        include: Optional[types.bookmarkInclude] = None,
        order: Optional[Union[types.bookmarkOrderByInput, List[types.bookmarkOrderByInput]]] = None,
        distinct: Optional[List[types.bookmarkScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single bookmark record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            bookmark filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned bookmark model
        order
            Order the returned bookmark records by any field
        distinct
            Filter bookmark records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.bookmark
            The first bookmark record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second bookmark record ordered by the job_id field
        bookmark = bookmark.prisma().find_first_or_raise(
            skip=1,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.bookmarkUpdateInput,
        where: types.bookmarkWhereUniqueInput,
        include: Optional[types.bookmarkInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single bookmark record.

        Parameters
        ----------
        data
            bookmark record data specifying what to update
        where
            bookmark filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The updated bookmark record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        bookmark = bookmark.prisma().update(
            where={
                'book_id': 76790008,
            },
            data={
                # data to update the bookmark record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.bookmarkWhereUniqueInput,
        data: types.bookmarkUpsertInput,
        include: Optional[types.bookmarkInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            bookmark filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned bookmark model

        Returns
        -------
        prisma.models.bookmark
            The created or updated bookmark record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        bookmark = bookmark.prisma().upsert(
            where={
                'book_id': 2098299345,
            },
            data={
                'create': {
                    'book_id': 2098299345,
                    'user_id': 1047820095,
                    'job_id': 1302734860,
                },
                'update': {
                    'user_id': 1047820095,
                    'job_id': 1302734860,
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.bookmarkUpdateManyMutationInput,
        where: types.bookmarkWhereInput,
    ) -> int:
        """Update multiple bookmark records

        Parameters
        ----------
        data
            bookmark data to update the selected bookmark records to
        where
            Filter to select the bookmark records to update

        Returns
        -------
        int
            The total number of bookmark records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all bookmark records
        total = bookmark.prisma().update_many(
            data={
                'book_id': 245900342
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
    ) -> int:
        """Count the number of bookmark records present in the database

        Parameters
        ----------
        select
            Select the bookmark fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            bookmark filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.bookmarkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = bookmark.prisma().count()

        # results: prisma.types.bookmarkCountAggregateOutput
        results = bookmark.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.bookmarkCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
    ) -> types.bookmarkCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.bookmarkCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.bookmarkWhereInput] = None,
        cursor: Optional[types.bookmarkWhereUniqueInput] = None,
    ) -> Union[int, types.bookmarkCountAggregateOutput]:
        """Count the number of bookmark records present in the database

        Parameters
        ----------
        select
            Select the bookmark fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            bookmark filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.bookmarkCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = bookmark.prisma().count()

        # results: prisma.types.bookmarkCountAggregateOutput
        results = bookmark.prisma().count(
            select={
                '_all': True,
                'job_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.bookmarkCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.bookmarkWhereInput] = None
    ) -> int:
        """Delete multiple bookmark records.

        Parameters
        ----------
        where
            Optional bookmark filter to find the records to be deleted

        Returns
        -------
        int
            The total number of bookmark records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all bookmark records
        total = bookmark.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.bookmarkScalarFieldKeys'],
        *,
        where: Optional['types.bookmarkWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.bookmarkAvgAggregateInput'] = None,
        sum: Optional['types.bookmarkSumAggregateInput'] = None,
        min: Optional['types.bookmarkMinAggregateInput'] = None,
        max: Optional['types.bookmarkMaxAggregateInput'] = None,
        having: Optional['types.bookmarkScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.bookmarkCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.bookmarkScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.bookmarkScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.bookmarkGroupByOutput']:
        """Group bookmark records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar bookmark fields to group records by
        where
            bookmark filter to select records
        take
            Limit the maximum number of bookmark records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.bookmarkGroupByOutput]
            A list of dictionaries representing the bookmark record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group bookmark records by book_id values
        # and count how many records are in each group
        results = bookmark.prisma().group_by(
            ['book_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]


class postActions(Generic[_PrismaModelT]):
    __slots__ = (
        '_client',
        '_model',
    )

    def __init__(self, client: Prisma, model: Type[_PrismaModelT]) -> None:
        self._client = client
        self._model = model

    def query_raw(
        self,
        query: LiteralString,
        *args: Any,
    ) -> List[_PrismaModelT]:
        """Execute a raw SQL query

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        List[prisma.models.post]
            The records returned by the SQL query

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        users = post.prisma().query_raw(
            'SELECT * FROM post WHERE job_id = $1',
            811863863,
        )
        ```
        """
        return self._client.query_raw(query, *args, model=self._model)

    def query_first(
        self,
        query: LiteralString,
        *args: Any,
    ) -> Optional[_PrismaModelT]:
        """Execute a raw SQL query, returning the first result

        Parameters
        ----------
        query
            The raw SQL query string to be executed
        *args
            Parameters to be passed to the SQL query, these MUST be used over
            string formatting to avoid an SQL injection vulnerability

        Returns
        -------
        prisma.models.post
            The first record returned by the SQL query
        None
            The raw SQL query did not return any records

        Raises
        ------
        prisma_errors.RawQueryError
            This could be due to invalid syntax, mismatched number of parameters or any other error
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        user = post.prisma().query_first(
            'SELECT * FROM post WHERE user_id = $1',
            1388801188,
        )
        ```
        """
        return self._client.query_first(query, *args, model=self._model)

    def create(
        self,
        data: types.postCreateInput,
        include: Optional[types.postInclude] = None
    ) -> _PrismaModelT:
        """Create a new post record.

        Parameters
        ----------
        data
            post record data
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The created post record

        Raises
        ------
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # create a post record from just the required fields
        post = post.prisma().create(
            data={
                # data to create a post record
                'job_id': 752577037,
                'user_id': 1187663298,
            },
        )
        ```
        """
        resp = self._client._execute(
            method='create',
            model=self._model,
            arguments={
                'data': data,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def create_many(
        self,
        data: List[types.postCreateWithoutRelationsInput],
        *,
        skip_duplicates: Optional[bool] = None,
    ) -> int:
        """Create multiple post records at once.

        This function is *not* available when using SQLite.

        Parameters
        ----------
        data
            List of post record data
        skip_duplicates
            Boolean flag for ignoring unique constraint errors

        Returns
        -------
        int
            The total number of records created

        Raises
        ------
        prisma.errors.UnsupportedDatabaseError
            Attempting to query when using SQLite
        prisma.errors.UniqueViolationError
            A unique constraint check has failed, these can be ignored with the `skip_duplicates` argument
        prisma.errors.MissingRequiredValueError
            Value is required but was not found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        total = post.prisma().create_many(
            data=[
                {
                    # data to create a post record
                    'job_id': 769681363,
                    'user_id': 1214295824,
                },
                {
                    # data to create a post record
                    'job_id': 1021417993,
                    'user_id': 351503374,
                },
            ],
            skip_duplicates=True,
        )
        ```
        """
        if self._client._active_provider == 'sqlite':
            raise errors.UnsupportedDatabaseError('sqlite', 'create_many()')

        resp = self._client._execute(
            method='create_many',
            model=self._model,
            arguments={
                'data': data,
                'skipDuplicates': skip_duplicates,
            },
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    def delete(
        self,
        where: types.postWhereUniqueInput,
        include: Optional[types.postInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Delete a single post record.

        Parameters
        ----------
        where
            post filter to select the record to be deleted, must be unique
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The deleted post record
        None
            Could not find a record to delete

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = post.prisma().delete(
            where={
                # post where unique filter

            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='delete',
                model=self._model,
                arguments={
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def find_unique(
        self,
        where: types.postWhereUniqueInput,
        include: Optional[types.postInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Find a unique post record.

        Parameters
        ----------
        where
            post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The found post record
        None
            No record matching the given input could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = post.prisma().find_unique(
            where={
                # post where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None
        return model_parse(self._model, result)

    def find_unique_or_raise(
        self,
        where: types.postWhereUniqueInput,
        include: Optional[types.postInclude] = None
    ) -> _PrismaModelT:
        """Find a unique post record. Raises `RecordNotFoundError` if no record is found.

        Parameters
        ----------
        where
            post filter to find the record, must be unique
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The found post record

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = post.prisma().find_unique_or_raise(
            where={
                # post where unique filter

            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_unique_or_raise',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def find_many(
        self,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
        include: Optional[types.postInclude] = None,
        order: Optional[Union[types.postOrderByInput, List[types.postOrderByInput]]] = None,
        distinct: Optional[List[types.postScalarFieldKeys]] = None,
    ) -> List[_PrismaModelT]:
        """Find multiple post records.

        An empty list is returned if no records could be found.

        Parameters
        ----------
        take
            Limit the maximum number of post records returned
        skip
            Ignore the first N results
        where
            post filter to select records
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned post model
        order
            Order the returned post records by any field
        distinct
            Filter post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        List[prisma.models.post]
            The list of all post records that could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the first 10 post records
        posts = post.prisma().find_many(take=10)

        # find the first 5 post records ordered by the job_id field
        posts = post.prisma().find_many(
            take=5,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_many',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return [model_parse(self._model, r) for r in resp['data']['result']]

    def find_first(
        self,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
        include: Optional[types.postInclude] = None,
        order: Optional[Union[types.postOrderByInput, List[types.postOrderByInput]]] = None,
        distinct: Optional[List[types.postScalarFieldKeys]] = None,
    ) -> Optional[_PrismaModelT]:
        """Find a single post record.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned post model
        order
            Order the returned post records by any field
        distinct
            Filter post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.post
            The first post record found, matching the given arguments
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second post record ordered by the user_id field
        post = post.prisma().find_first(
            skip=1,
            order={
                'user_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        result = resp['data']['result']
        if result is None:
            return None

        return model_parse(self._model, result)

    def find_first_or_raise(
        self,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
        include: Optional[types.postInclude] = None,
        order: Optional[Union[types.postOrderByInput, List[types.postOrderByInput]]] = None,
        distinct: Optional[List[types.postScalarFieldKeys]] = None,
    ) -> _PrismaModelT:
        """Find a single post record. Raises `RecordNotFoundError` if no record was found.

        Parameters
        ----------
        skip
            Ignore the first N records
        where
            post filter to select the record
        cursor
            Specifies the position in the list to start returning results from, (typically an ID field)
        include
            Specifies which relations should be loaded on the returned post model
        order
            Order the returned post records by any field
        distinct
            Filter post records by either a single distinct field or distinct combinations of fields

        Returns
        -------
        prisma.models.post
            The first post record found, matching the given arguments

        Raises
        ------
        prisma.errors.RecordNotFoundError
            No record was found
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # find the second post record ordered by the job_id field
        post = post.prisma().find_first_or_raise(
            skip=1,
            order={
                'job_id': 'desc',
            },
        )
        ```
        """
        resp = self._client._execute(
            method='find_first_or_raise',
            model=self._model,
            arguments={
                'skip': skip,
                'where': where,
                'order_by': order,
                'cursor': cursor,
                'include': include,
                'distinct': distinct,
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update(
        self,
        data: types.postUpdateInput,
        where: types.postWhereUniqueInput,
        include: Optional[types.postInclude] = None
    ) -> Optional[_PrismaModelT]:
        """Update a single post record.

        Parameters
        ----------
        data
            post record data specifying what to update
        where
            post filter to select the unique record to create / update
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The updated post record
        None
            No record could be found

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        post = post.prisma().update(
            where={
                # post where unique filter

            },
            data={
                # data to update the post record to
            },
        )
        ```
        """
        try:
            resp = self._client._execute(
                method='update',
                model=self._model,
                arguments={
                    'data': data,
                    'where': where,
                    'include': include,
                },
            )
        except errors.RecordNotFoundError:
            return None

        return model_parse(self._model, resp['data']['result'])

    def upsert(
        self,
        where: types.postWhereUniqueInput,
        data: types.postUpsertInput,
        include: Optional[types.postInclude] = None,
    ) -> _PrismaModelT:
        """Updates an existing record or create a new one

        Parameters
        ----------
        where
            post filter to select the unique record to create / update
        data
            Data specifying what fields to set on create and update
        include
            Specifies which relations should be loaded on the returned post model

        Returns
        -------
        prisma.models.post
            The created or updated post record

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python
        prisma.errors.MissingRequiredValueError
            Value is required but was not found

        Example
        -------
        ```py
        post = post.prisma().upsert(
            where={
                # post where unique filter
            },
            data={
                'create': {
                    # post data to be set if the record does not exist
                },
                'update': {
                    # post data to be set if the record does exist
                },
            },
        )
        ```
        """
        resp = self._client._execute(
            method='upsert',
            model=self._model,
            arguments={
                'where': where,
                'include': include,
                'create': data.get('create'),
                'update': data.get('update'),
            },
        )
        return model_parse(self._model, resp['data']['result'])

    def update_many(
        self,
        data: types.postUpdateManyMutationInput,
        where: types.postWhereInput,
    ) -> int:
        """Update multiple post records

        Parameters
        ----------
        data
            post data to update the selected post records to
        where
            Filter to select the post records to update

        Returns
        -------
        int
            The total number of post records that were updated

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # update all post records
        total = post.prisma().update_many(
            data={
                'user_id': 1321184815
            },
            where={}
        )
        ```
        """
        resp = self._client._execute(
            method='update_many',
            model=self._model,
            arguments={'data': data, 'where': where,},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    @overload
    def count(
        self,
        select: None = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
    ) -> int:
        """Count the number of post records present in the database

        Parameters
        ----------
        select
            Select the post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.postCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = post.prisma().count()

        # results: prisma.types.postCountAggregateOutput
        results = post.prisma().count(
            select={
                '_all': True,
                'job_id': True,
            },
        )
        ```
        """


    @overload
    def count(
        self,
        select: types.postCountAggregateInput,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
    ) -> types.postCountAggregateOutput:
        ...

    def count(
        self,
        select: Optional[types.postCountAggregateInput] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        where: Optional[types.postWhereInput] = None,
        cursor: Optional[types.postWhereUniqueInput] = None,
    ) -> Union[int, types.postCountAggregateOutput]:
        """Count the number of post records present in the database

        Parameters
        ----------
        select
            Select the post fields to be counted
        take
            Limit the maximum result
        skip
            Ignore the first N records
        where
            post filter to find records
        cursor
            Specifies the position in the list to start counting results from, (typically an ID field)
        order
            This parameter is deprecated and will be removed in a future release

        Returns
        -------
        int
            The total number of records found, returned if `select` is not given

        prisma.types.postCountAggregateOutput
            Data returned when `select` is used, the fields present in this dictionary will
            match the fields passed in the `select` argument

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # total: int
        total = post.prisma().count()

        # results: prisma.types.postCountAggregateOutput
        results = post.prisma().count(
            select={
                '_all': True,
                'user_id': True,
            },
        )
        ```
        """

        # TODO: this selection building should be moved to the QueryBuilder
        #
        # note the distinction between checking for `not select` here and `select is None`
        # later is to handle the case that the given select dictionary is empty, this
        # is a limitation of our types.
        if not select:
            root_selection = ['_count { _all }']
        else:

            root_selection = [
                '_count {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))
            ]

        resp = self._client._execute(
            method='count',
            model=self._model,
            arguments={
                'take': take,
                'skip': skip,
                'where': where,
                'cursor': cursor,
            },
            root_selection=root_selection,
        )

        if select is None:
            return cast(int, resp['data']['result']['_count']['_all'])
        else:
            return cast(types.postCountAggregateOutput, resp['data']['result']['_count'])

    def delete_many(
        self,
        where: Optional[types.postWhereInput] = None
    ) -> int:
        """Delete multiple post records.

        Parameters
        ----------
        where
            Optional post filter to find the records to be deleted

        Returns
        -------
        int
            The total number of post records that were deleted

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # delete all post records
        total = post.prisma().delete_many()
        ```
        """
        resp = self._client._execute(
            method='delete_many',
            model=self._model,
            arguments={'where': where},
            root_selection=['count'],
        )
        return int(resp['data']['result']['count'])

    # TODO: make this easier to work with safely, currently output fields are typed as
    #       not required, we should refactor the return type
    # TODO: consider returning a Dict where the keys are a Tuple of the `by` selection
    # TODO: statically type that the order argument is required when take or skip are present
    def group_by(
        self,
        by: List['types.postScalarFieldKeys'],
        *,
        where: Optional['types.postWhereInput'] = None,
        take: Optional[int] = None,
        skip: Optional[int] = None,
        avg: Optional['types.postAvgAggregateInput'] = None,
        sum: Optional['types.postSumAggregateInput'] = None,
        min: Optional['types.postMinAggregateInput'] = None,
        max: Optional['types.postMaxAggregateInput'] = None,
        having: Optional['types.postScalarWhereWithAggregatesInput'] = None,
        count: Optional[Union[bool, 'types.postCountAggregateInput']] = None,
        order: Optional[Union[Mapping['types.postScalarFieldKeys', 'types.SortOrder'], List[Mapping['types.postScalarFieldKeys', 'types.SortOrder']]]] = None,
    ) -> List['types.postGroupByOutput']:
        """Group post records by one or more field values and perform aggregations
        each group such as finding the average.

        Parameters
        ----------
        by
            List of scalar post fields to group records by
        where
            post filter to select records
        take
            Limit the maximum number of post records returned
        skip
            Ignore the first N records
        avg
            Adds the average of all values of the specified fields to the `_avg` field
            in the returned data.
        sum
            Adds the sum of all values of the specified fields to the `_sum` field
            in the returned data.
        min
            Adds the smallest available value for the specified fields to the `_min` field
            in the returned data.
        max
            Adds the largest available value for the specified fields to the `_max` field
            in the returned data.
        count
            Adds a count of non-fields to the `_count` field in the returned data.
        having
            Allows you to filter groups by an aggregate value - for example only return
            groups having an average age less than 50.
        order
            Lets you order the returned list by any property that is also present in `by`.
            Only **one** field is allowed at a time.

        Returns
        -------
        List[prisma.types.postGroupByOutput]
            A list of dictionaries representing the post record,
            this will also have additional fields present if aggregation arguments
            are used (see the above parameters)

        Raises
        ------
        prisma.errors.PrismaError
            Catch all for every exception raised by Prisma Client Python

        Example
        -------
        ```py
        # group post records by job_id values
        # and count how many records are in each group
        results = post.prisma().group_by(
            ['job_id'],
            count=True,
        )
        ```
        """
        if order is None:
            if take is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'take\' is present')

            if skip is not None:
                raise TypeError('Missing argument: \'order\' which is required when \'skip\' is present')

        root_selection: List[str] = [*by]
        if avg is not None:
            root_selection.append(_select_fields('_avg', avg))

        if min is not None:
            root_selection.append(_select_fields('_min', min))

        if sum is not None:
            root_selection.append(_select_fields('_sum', sum))

        if max is not None:
            root_selection.append(_select_fields('_max', max))

        if count is not None:
            if count is True:
                root_selection.append('_count { _all }')
            elif isinstance(count, dict):
                root_selection.append(_select_fields('_count', count))

        resp = self._client._execute(
            method='group_by',
            model=self._model,
            arguments={
                'by': by,
                'take': take,
                'skip': skip,
                'where': where,
                'having': having,
                'orderBy': order,
            },
            root_selection=root_selection,
        )
        return resp['data']['result']  # type: ignore[no-any-return]



def _select_fields(root: str, select: Mapping[str, Any]) -> str:
    """Helper to build a GraphQL selection string

    This is a work around until field selection is added to the query builder.
    """

    return root + ' {{ {0} }}'.format(' '.join(k for k, v in select.items() if v is True))


from . import models